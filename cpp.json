{
	"code": {
	"prefix": "code",
	"body": [
		"#include<bits/allocator.h>",
		"#pragma GCC optimize(\"Ofast,unroll-loops\")",
		"#pragma GCC target(\"avx2,fma,bmi,bmi2,popcnt,lzcnt,tune=native\")",
		"",
		"#include<bits/stdc++.h>",
		"using namespace std;",
		"#define ll long long",
		"#define ull unsigned long long",
		"#define int128 __int128_t",
		"#define double long double",
		"#define gcd __gcd",
		"#define lcm(a, b) ((a)/gcd(a, b)*(b))",
		"#define sqrt sqrtl",
		"#define log2 log2l",
		"#define log10 log10l",
		"#define floor floorl",
		"#define to_string str",
		"#define yes cout << \"YES\"",
		"#define no cout << \"NO\"",
		"#define trav(i, a) for (auto &i: (a))",
		"#define all(a) (a).begin(), (a).end()",
		"#define rall(a) (a).rbegin(), (a).rend()",
		"#define sz(a) (int)a.size()",
		"#define Max(a) *max_element(all(a))",
		"#define Min(a) *min_element(all(a))",
		"#define Find(a, n) (find(all(a), n) - a.begin())",
		"#define Count(a, n) count(all(a), n)",
		"#define Upper(a, n) (upper_bound(all(a), n) - a.begin())",
		"#define Lower(a, n) (lower_bound(all(a), n) - a.begin())",
		"#define next_perm(a) next_permutation(all(a))",
		"#define prev_perm(a) prev_permutation(all(a))",
		"#define sorted(a) is_sorted(all(a))",
		"#define sum(a) accumulate(all(a), 0)",
		"#define sumll(a) accumulate(all(a), 0ll)",
		"#define Sort(a) sort(all(a))",
		"#define Reverse(a) reverse(all(a))",
		"#define Unique(a) Sort(a), (a).resize(unique(all(a)) - a.begin())",
		"#define pb push_back",
		"#define eb emplace_back",
		"#define popcount __builtin_popcount",
		"#define popcountll __builtin_popcountll",
		"#define clz __builtin_clz",
		"#define clzll __buitlin_clzll",
		"#define ctz __builtin_ctz",
		"#define ctzll __builtin_ctzll",
		"#define open(s) freopen(s, \"r\", stdin)",
		"#define write(s) freopen(s, \"w\", stdout)",
		"#define fileopen(s) open((string(s) + \".inp\").c_str()), write((string(s) + \".out\").c_str());",
		"#define For(i, a, b) for (auto i = (a); i < (b); i++)",
		"#define Fore(i, a, b) for (auto i = (a); i >= (b); i--)",
		"#define FOR(i, a, b) for (auto i = (a); i <= (b); i++)",
		"#define ret(s) return void(cout << s);",
		"",
		"const int mod = 1e9 + 7, mod2 = 998244353;",
		"const double PI = acos(-1), eps = 1e-9;",
		"const ull npos = string::npos;",
		"const int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};",
		"using pii = pair<int, int>;",
		"using pll = pair<ll, ll>;",
		"using cd = complex<double>;",
		"mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());",
		"typedef vector<int> vi;",
		"typedef vector<vi> vvi;",
		"typedef vector<ll> vll;",
		"typedef vector<vll> vvll;",
		"typedef vector<double> vdo;",
		"typedef vector<vdo> vvdo;",
		"typedef vector<string> vs;",
		"typedef vector<pii> vpair;",
		"typedef vector<vpair> vvpair;",
		"typedef vector<bool> vb;",
		"typedef vector<vb> vvb;",
		"typedef vector<char> vc;",
		"typedef vector<vc> vvc;",
		"typedef vector<cd> vcd;",
		"typedef priority_queue<int> pq;",
		"typedef priority_queue<int, vi, greater<int>> pqg;",
		"typedef priority_queue<ll> pqll;",
		"typedef priority_queue<ll, vll, greater<ll>> pqgll;",
		"",
		"ll add(ll a, ll b, int m) {if (a >= m) a%=m;if (b >= m) b%=m;a+=b;return a >= m ? a - m: a;}",
		"ll sub(ll a, ll b, int m) {if (a >= m) a%=m;if (b >= m) b%=m;a-=b;return a < 0 ? a + m: a;}",
		"ll mul(ll a, ll b, int m) {if (a >= m) a%=m;if (b >= m) b%=m;return a*b % m;}",
		"ll bin_mul(ll a, ll b, ll m) {if (a >= m) a%=m;if (b >= m) b%=m;ll x = 0;while (b) {if (b & 1) x = (x + a) % m;a = (a + a) % m;b>>=1;}return x;}",
		"ll power(ll a, ll b, int m) {ll x = 1;if (a >= m) a%=m; while (b) {if (b & 1) x = x*a % m;a = a*a % m;b>>=1;}return x;}",
		"ll power(ll a, ll b) {ll x = 1;while (b) {if (b & 1) x = x*a;a = a*a;b>>=1;}return x;}",
		"ll ceil(ll a, ll b) {return (a + b - 1)/b;}",
		"ll to_int(const string &s) {ll x = 0; for (int i = (s[0] == '-'); i < sz(s); i++) x = x*10 + s[i] - '0';return x*(s[0] == '-' ? -1: 1);}",
		"bool is_prime(ll n) {if (n < 2) return 0;if (n < 4) return 1;if (n % 2 == 0 || n % 3 == 0) return 0;for (ll i = 5; i*i <= n; i+=6) {if(n % i == 0 || n % (i + 2) == 0) return 0;}return 1;}",
		"bool is_square(ll n) {ll k = sqrt(n); return k*k == n;}",
		"ll factorial(int n) {ll x = 1;for (int i = 2; i <= n; i++) x*=i;return x;}",
		"ll factorial(int n, int m) {ll x = 1;for (ll i = 2; i <= n; i++) x = x*i % m;return x;}",
		"bool is_power(ll n, ll k) {while (n % k == 0) n/=k;return n == 1ll;}",
		"string str(ll n) {if (n == 0) return \"0\"; string s = \"\"; bool c = 0; if (n < 0) c = 1, n = -n; while (n) {s+=n % 10 + '0'; n/=10;} if (c) s+='-'; Reverse(s); return s;}",
		"string repeat(const string &s, int n) {if (n < 0) return \"\"; string x = \"\"; while (n--) x+=s; return x;}",
		"string bin(ll n) {string s = \"\"; while (n) {s+=(n & 1) + '0'; n>>=1;} Reverse(s); return s;}",
		"void sieve(vector<bool> &a) {int n = a.size(); a[0] = a[1] = 0; for (int i = 4; i < n; i+=2) a[i] = 0; for (int i = 3; i*i < n; i+=2) {if (a[i]) {for (int j = i*i; j < n; j+=(i << 1)) a[j] = 0;}}}",
		"void sieve(bool a[], int n) {a[0] = a[1] = 0; for (int i = 4; i < n; i+=2) a[i] = 0; for (int i = 3; i*i < n; i+=2) {if (a[i]) {for (int j = i*i; j < n; j+=(i << 1)) a[j] = 0;}}}",
		"void sieve(vector<int> &a) {int n = a.size(); for (int i = 2; i < n; i+=2) a[i] = 2; for (int i = 3; i*i < n; i+=2) {if (!a[i]) {for (int j = i; j < n; j+=(i << 1)) a[j] = i;}} for (int i = 3; i < n; i+=2) {if (!a[i]) a[i] = i;}}",
		"void sieve(int a[], int n) {for (int i = 2; i < n; i+=2) a[i] = 2; for (int i = 3; i*i < n; i+=2) {if (!a[i]) {for (int j = i; j < n; j+=(i << 1)) a[j] = i;}} for (int i = 3; i < n; i+=2) {if (!a[i]) a[i] = i;}}",
		"vector<pii> factorize(int n) {vector<pii> a; for (int i = 2; i*i <= n; i++) {if (n % i == 0) {int k = 0; while (n % i == 0) k++, n/=i; a.emplace_back(i, k);}} if (n > 1) a.emplace_back(n, 1); return a;}",
		"int rand(int l, int r) {return uniform_int_distribution<int>(l, r)(mt);}",
		"int Log2(int n) {return 31 - __builtin_clz(n);}",
		"template<class T> void compress(vector<T> &a) {vector<T> b; for (T &i: a) b.push_back(i); sort(all(b)); b.resize(unique(all(b)) - b.begin()); for (T &i: a) i = lower_bound(all(b), i) - b.begin() + 1;}",
		"",
		"template<class A, class B> istream& operator>>(istream& in, pair<A, B> &p) {in >> p.first >> p.second; return in;}",
		"template<class A, class B> ostream& operator<<(ostream& out, const pair<A, B> &p) {out << p.first << ' ' << p.second; return out;}",
		"template<class T> istream& operator>>(istream& in, vector<T> &a) {for (auto &i: a) in >> i; return in;}",
		"template<class T> ostream& operator<<(ostream& out, const vector<T> &a) {for (auto &i: a) out << i << ' '; return out;}",
		"template<class T> istream& operator>>(istream& in, vector<vector<T>> &a) {for (auto &i: a) in >> i; return in;}",
		"template<class T> ostream& operator<<(ostream& out, const vector<vector<T>> &a) {for (auto &i: a) out << i << '\\n'; return out;}",
		"template<class T> istream& operator>>(istream& in, deque<T> &a) {for (auto &i: a) in >> i; return in;}",
		"template<class T> ostream& operator<<(ostream& out, const deque<T> &a) {for (auto &i: a) out << i << ' '; return out;}",
		"// istream& operator>>(istream& in, __int128_t &a) {string s; in >> s; a = 0; for (auto &i: s) a = a*10 + (i - '0'); return in;}",
		"// ostream& operator<<(ostream& out, __int128_t a) {string s = \"\"; while (a > 0) {s+=(int)(a % 10) + '0'; a/=10;} Reverse(s); out << s; return out;}",
		"",
		"int main() {",
		"    ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);",
		"    cout << fixed << setprecision(10);",
		"    ",
		"    cerr << \"\\nProcess returned 0 (0x0)   execution time :  \" << 0.001*clock() << \" s\";",
		"    return 0;",
		"}",
		""
	],
	"description": "code"
	},
	"stress": {
	"prefix": "stress",
	"body": [
		"#include<bits/allocator.h>",
		"#pragma GCC optimize(\"Ofast,unroll-loops\")",
		"#pragma GCC target(\"avx2,fma,bmi,bmi2,popcnt,lzcnt,tune=native\")",
		" ",
		"#include<bits/stdc++.h>",
		"using namespace std;",
		"#define ll long long",
		"#define ull unsigned long long",
		"#define int128 __int128_t",
		"#define double long double",
		"#define gcd __gcd",
		"#define lcm(a, b) ((a)/gcd(a, b)*(b))",
		"#define sqrt sqrtl",
		"#define log2 log2l",
		"#define log10 log10l",
		"#define floor floorl",
		"#define to_string str",
		"#define yes cout << \"YES\"",
		"#define no cout << \"NO\"",
		"#define trav(i, a) for (auto &i: (a))",
		"#define all(a) (a).begin(), (a).end()",
		"#define rall(a) (a).rbegin(), (a).rend()",
		"#define sz(a) (int)a.size()",
		"#define Max(a) *max_element(all(a))",
		"#define Min(a) *min_element(all(a))",
		"#define Find(a, n) (find(all(a), n) - a.begin())",
		"#define Count(a, n) count(all(a), n)",
		"#define Upper(a, n) (upper_bound(all(a), n) - a.begin())",
		"#define Lower(a, n) (lower_bound(all(a), n) - a.begin())",
		"#define next_perm(a) next_permutation(all(a))",
		"#define prev_perm(a) prev_permutation(all(a))",
		"#define sorted(a) is_sorted(all(a))",
		"#define sum(a) accumulate(all(a), 0)",
		"#define sumll(a) accumulate(all(a), 0ll)",
		"#define Sort(a) sort(all(a))",
		"#define Reverse(a) reverse(all(a))",
		"#define Unique(a) Sort(a), (a).resize(unique(all(a)) - a.begin())",
		"#define pb push_back",
		"#define eb emplace_back",
		"#define popcount __builtin_popcount",
		"#define popcountll __builtin_popcountll",
		"#define clz __builtin_clz",
		"#define clzll __buitlin_clzll",
		"#define ctz __builtin_ctz",
		"#define ctzll __builtin_ctzll",
		"#define open(s) freopen(s, \"r\", stdin)",
		"#define write(s) freopen(s, \"w\", stdout)",
		"#define fileopen(s) open((string(s) + \".inp\").c_str()), write((string(s) + \".out\").c_str());",
		"#define For(i, a, b) for (auto i = (a); i < (b); i++)",
		"#define Fore(i, a, b) for (auto i = (a); i >= (b); i--)",
		"#define FOR(i, a, b) for (auto i = (a); i <= (b); i++)",
		"#define ret(s) return void(cout << s);",
		"",
		"const int mod = 1e9 + 7, mod2 = 998244353;",
		"const double PI = acos(-1), eps = 1e-9;",
		"const ull npos = string::npos;",
		"const int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};",
		"using pii = pair<int, int>;",
		"using pll = pair<ll, ll>;",
		"using cd = complex<double>;",
		"mt19937 mt(chrono::system_clock::now().time_since_epoch().count());",
		"typedef vector<int> vi;",
		"typedef vector<vi> vvi;",
		"typedef vector<ll> vll;",
		"typedef vector<vll> vvll;",
		"typedef vector<double> vdo;",
		"typedef vector<vdo> vvdo;",
		"typedef vector<string> vs;",
		"typedef vector<pii> vpair;",
		"typedef vector<vpair> vvpair;",
		"typedef vector<bool> vb;",
		"typedef vector<vb> vvb;",
		"typedef vector<char> vc;",
		"typedef vector<vc> vvc;",
		"typedef vector<cd> vcd;",
		"typedef priority_queue<int> pq;",
		"typedef priority_queue<int, vi, greater<int>> pqg;",
		"typedef priority_queue<ll> pqll;",
		"typedef priority_queue<ll, vll, greater<ll>> pqgll;",
		"",
		"ll add(ll a, ll b, int m) {if (a >= m) a%=m;if (b >= m) b%=m;a+=b;return a >= m ? a - m: a;}",
		"ll sub(ll a, ll b, int m) {if (a >= m) a%=m;if (b >= m) b%=m;a-=b;return a < 0 ? a + m: a;}",
		"ll mul(ll a, ll b, int m) {if (a >= m) a%=m;if (b >= m) b%=m;return a*b % m;}",
		"ll bin_mul(ll a, ll b, ll m) {if (a >= m) a%=m;if (b >= m) b%=m;ll x = 0;while (b) {if (b & 1) x = (x + a) % m;a = (a + a) % m;b>>=1;}return x;}",
		"ll power(ll a, ll b, int m) {ll x = 1;if (a >= m) a%=m; while (b) {if (b & 1) x = x*a % m;a = a*a % m;b>>=1;}return x;}",
		"ll power(ll a, ll b) {ll x = 1;while (b) {if (b & 1) x = x*a;a = a*a;b>>=1;}return x;}",
		"ll ceil(ll a, ll b) {return (a + b - 1)/b;}",
		"ll to_int(const string &s) {ll x = 0; for (int i = (s[0] == '-'); i < sz(s); i++) x = x*10 + s[i] - '0';return x*(s[0] == '-' ? -1: 1);}",
		"bool is_prime(ll n) {if (n < 2) return 0;if (n < 4) return 1;if (n % 2 == 0 || n % 3 == 0) return 0;for (ll i = 5; i*i <= n; i+=6) {if(n % i == 0 || n % (i + 2) == 0) return 0;}return 1;}",
		"bool is_square(ll n) {ll k = sqrt(n); return k*k == n;}",
		"ll factorial(int n) {ll x = 1;for (int i = 2; i <= n; i++) x*=i;return x;}",
		"ll factorial(int n, int m) {ll x = 1;for (ll i = 2; i <= n; i++) x = x*i % m;return x;}",
		"bool is_power(ll n, ll k) {while (n % k == 0) n/=k;return n == 1ll;}",
		"string str(ll n) {if (n == 0) return \"0\"; string s = \"\"; bool c = 0; if (n < 0) c = 1, n = -n; while (n) {s+=n % 10 + '0'; n/=10;} if (c) s+='-'; Reverse(s); return s;}",
		"string repeat(const string &s, int n) {if (n < 0) return \"\"; string x = \"\"; while (n--) x+=s; return x;}",
		"string bin(ll n) {string s = \"\"; while (n) {s+=(n & 1) + '0'; n>>=1;} Reverse(s); return s;}",
		"void sieve(vector<bool> &a) {int n = a.size(); a[0] = a[1] = 0; for (int i = 4; i < n; i+=2) a[i] = 0; for (int i = 3; i*i < n; i+=2) {if (a[i]) {for (int j = i*i; j < n; j+=(i << 1)) a[j] = 0;}}}",
		"void sieve(bool a[], int n) {a[0] = a[1] = 0; for (int i = 4; i < n; i+=2) a[i] = 0; for (int i = 3; i*i < n; i+=2) {if (a[i]) {for (int j = i*i; j < n; j+=(i << 1)) a[j] = 0;}}}",
		"void sieve(vector<int> &a) {int n = a.size(); for (int i = 2; i < n; i+=2) a[i] = 2; for (int i = 3; i*i < n; i+=2) {if (!a[i]) {for (int j = i; j < n; j+=(i << 1)) a[j] = i;}} for (int i = 3; i < n; i+=2) {if (!a[i]) a[i] = i;}}",
		"void sieve(int a[], int n) {for (int i = 2; i < n; i+=2) a[i] = 2; for (int i = 3; i*i < n; i+=2) {if (!a[i]) {for (int j = i; j < n; j+=(i << 1)) a[j] = i;}} for (int i = 3; i < n; i+=2) {if (!a[i]) a[i] = i;}}",
		"vector<pii> factorize(int n) {vector<pii> a; for (int i = 2; i*i <= n; i++) {if (n % i == 0) {int k = 0; while (n % i == 0) k++, n/=i; a.emplace_back(i, k);}} if (n > 1) a.emplace_back(n, 1); return a;}",
		"int rand(int l, int r) {return uniform_int_distribution<int>(l, r)(mt);}",
		"int Log2(int n) {return 31 - __builtin_clz(n);}",
		"template<class T> void compress(vector<T> &a) {vector<T> b; for (T &i: a) b.push_back(i); sort(all(b)); b.resize(unique(all(b)) - b.begin()); for (T &i: a) i = lower_bound(all(b), i) - b.begin() + 1;}",
		"",
		"template<class A, class B> istream& operator>>(istream& in, pair<A, B> &p) {in >> p.first >> p.second; return in;}",
		"template<class A, class B> ostream& operator<<(ostream& out, const pair<A, B> &p) {out << p.first << ' ' << p.second; return out;}",
		"template<class T> istream& operator>>(istream& in, vector<T> &a) {for (auto &i: a) in >> i; return in;}",
		"template<class T> ostream& operator<<(ostream& out, const vector<T> &a) {for (auto &i: a) out << i << ' '; return out;}",
		"template<class T> istream& operator>>(istream& in, vector<vector<T>> &a) {for (auto &i: a) in >> i; return in;}",
		"template<class T> ostream& operator<<(ostream& out, const vector<vector<T>> &a) {for (auto &i: a) out << i << '\\n'; return out;}",
		"template<class T> istream& operator>>(istream& in, deque<T> &a) {for (auto &i: a) in >> i; return in;}",
		"template<class T> ostream& operator<<(ostream& out, const deque<T> &a) {for (auto &i: a) out << i << ' '; return out;}",
		"// istream& operator>>(istream& in, __int128_t &a) {string s; in >> s; a = 0; for (auto &i: s) a = a*10 + (i - '0'); return in;}",
		"// ostream& operator<<(ostream& out, __int128_t a) {string s = \"\"; while (a > 0) {s+=(int)(a % 10) + '0'; a/=10;} Reverse(s); out << s; return out;}",
		"",
		"int main() {",
		"    ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);",
		"    cout << fixed << setprecision(10);",
		"    int _ = 1;",
		"    while (_--) {",
		"        ofstream out(\"\");",
		"        ",
		"        out.close();",
		"        system(\".exe\"); system(\".exe\");",
		"        if (system(\"fc \") != 0) return 0;",
		"    }",
		"    cerr << \"\\nProcess returned 0 (0x0)   execution time :  \" << 0.001*clock() << \" s\";",
		"    return 0;",
		"}",
		""
	],
	"description": "stress"
	},
	"lah": {
	"prefix": "lah",
	"body": [
		"#include<bits/stdc++.h>",
		"using namespace std;",
		"#define ll long long",
		"#define sz(a) (int)a.size()",
		"#define all(a) (a).begin(), (a).end()",
		"#define rall(a) (a).rbegin(), (a).rend()",
		"#define open(s) freopen(s, \"r\", stdin)",
		"#define write(s) freopen(s, \"w\", stdout)",
		"using pii = pair<int, int>;",
		"using pll = pair<ll, ll>;",
		"using vi = vector<int>;",
		"using vll = vector<ll>;",
		"",
		"int main() {",
		"    //freopen(\"\", \"r\", stdin); freopen(\"\", \"w\", stdout);",
		"    ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);",
		"",
		"}"
	],
	"description": "lah"
	},
	"bit": {
	"prefix": "bit",
	"body": [
		"template<class T>",
		"struct BIT {",
		"    int n;",
		"    vector<T> b;",
		"    BIT(int n = 0): n(n) {b.assign(n + 1, 0);}",
		"    void build(const vector<T> &a) {",
		"        for (int i = 1; i <= n; i++) set(i, a[i]);",
		"    }",
		"    void set(int i, T v) {",
		"        for (; i <= n; i+=i & (-i)) b[i]+=v;",
		"    }",
		"    T get(int i) {",
		"        T x = 0;",
		"        for (; i; i-=i & (-i)) x+=b[i];",
		"        return x;",
		"    }",
		"    T get(int l, int r) {",
		"        return get(r) - get(l - 1);",
		"    }",
		"};"
	],
	"description": "bit"
	},
	"segtree_sum": {
	"prefix": "segtree_sum",
	"body": [
		"template<class T>",
		"struct segtree_sum {",
		"    int n;",
		"    vector<T> t;",
		"    T merge(T a, T b) {return a + b;}",
		"    void init(int N) {n = N; t.assign(2*n, 0);}",
		"    void set(int i, T v) {",
		"        for (t[i+=n] = v; i > 1; i>>=1) t[i >> 1] = merge(t[i], t[i^1]);",
		"    }",
		"    void build(const vector<T> &a) {",
		"        for (int i = 0; i < n; i++) set(i, a[i]);",
		"    }",
		"    T get(int l, int r) {",
		"        r++;",
		"        T x = 0;",
		"        for (l+=n, r+=n; l < r; l>>=1, r>>=1) {",
		"            if (l & 1) x = merge(x, t[l++]);",
		"            if (r & 1) x = merge(x, t[--r]);",
		"        }",
		"        return x;",
		"    }",
		"};"
	],
	"description": "segtree_sum"
	},
	"segtree_min": {
	"prefix": "segtree_min",
	"body": [
		"template<class T>",
		"struct segtree_min {",
		"    int n;",
		"    vector<T> t;",
		"    T merge(T a, T b) {return min(a, b);}",
		"    void init(int N) {n = N; t.assign(2*n, numeric_limits<T>::max());}",
		"    void set(int i, T v) {",
		"        for (t[i+=n] = v; i > 1; i>>=1) t[i >> 1] = merge(t[i], t[i^1]);",
		"    }",
		"    void build(const vector<T> &a) {",
		"        for (int i = 0; i < n; i++) set(i, a[i]);",
		"    }",
		"    T get(int l, int r) {",
		"        r++;",
		"        T x = numeric_limits<T>::max();",
		"        for (l+=n, r+=n; l < r; l>>=1, r>>=1) {",
		"            if (l & 1) x = merge(x, t[l++]);",
		"            if (r & 1) x = merge(x, t[--r]);",
		"        }",
		"        return x;",
		"    }",
		"};"
	],
	"description": "segtree_min"
	},
	"segtree_max": {
	"prefix": "segtree_max",
	"body": [
		"template<class T>",
		"struct segtree_max {",
		"    int n;",
		"    vector<T> t;",
		"    T merge(T a, T b) {return max(a, b);}",
		"    void init(int N) {n = N; t.assign(2*n, numeric_limits<T>::min());}",
		"    void set(int i, T v) {",
		"        for (t[i+=n] = v; i > 1; i>>=1) t[i >> 1] = merge(t[i], t[i^1]);",
		"    }",
		"    void build(const vector<T> &a) {",
		"        for (int i = 0; i < n; i++) set(i, a[i]);",
		"    }",
		"    T get(int l, int r) {",
		"        r++;",
		"        T x = numeric_limits<T>::min();",
		"        for (l+=n, r+=n; l < r; l>>=1, r>>=1) {",
		"            if (l & 1) x = merge(x, t[l++]);",
		"            if (r & 1) x = merge(x, t[--r]);",
		"        }",
		"        return x;",
		"    }",
		"};"
	],
	"description": "segtree_max"
	},
	"segtree_lazy_max": {
	"prefix": "segtree_lazy_max",
	"body": [
		"template<class T>",
		"struct segtree_lazy_max {",
		"    int n, h;",
		"    vector<T> t, d;",
		"    T merge(T a, T b) {return max(a, b);}",
		"    void init(int N) {n = N; h = 32 - __builtin_clz(n); t.assign(2*n, 0); d.assign(n, 0);}",
		"    void apply(int i, T v) {",
		"        t[i]+=v;",
		"        if (i < n) d[i]+=v;",
		"    }",
		"    void rebuild(int i) {",
		"        while (i > 1) i>>=1, t[i] = merge(t[i << 1], t[i << 1|1]) + d[i];",
		"    }",
		"    void push(int i) {",
		"        for (int j = h; j > 0; j--) {",
		"            int k = i >> j;",
		"            if (d[k] != 0) {",
		"                apply(k << 1, d[k]); apply(k << 1|1, d[k]);",
		"                d[k] = 0;",
		"            }",
		"        }",
		"    }",
		"    void set(int l, int r, T v) {",
		"        r++;",
		"        l+=n; r+=n;",
		"        int L = l, R = r;",
		"        for (; l < r; l>>=1, r>>=1) {",
		"            if (l & 1) apply(l++, v);",
		"            if (r & 1) apply(--r, v);",
		"        }",
		"        rebuild(L); rebuild(R - 1);",
		"    }",
		"    void build(const vector<T> &a) {",
		"        for (int i = 0; i < n; i++) set(i, i, a[i]);",
		"    }",
		"    T get(int l, int r) {",
		"        r++;",
		"        l+=n; r+=n;",
		"        push(l); push(r - 1);",
		"        T x = numeric_limits<T>::min();",
		"        for (; l < r; l>>=1, r>>=1) {",
		"            if (l & 1) x = merge(x, t[l++]);",
		"            if (r & 1) x = merge(x, t[--r]);",
		"        }",
		"        return x;",
		"    }",
		"};"
	],
	"description": "segtree_lazy_max"
	},
	"segtree_lazy_min": {
	"prefix": "segtree_lazy_min",
	"body": [
		"template<class T>",
		"struct segtree_lazy_min {",
		"    int n, h;",
		"    vector<T> t, d;",
		"    T merge(T a, T b) {return min(a, b);}",
		"    void init(int N) {n = N; h = 32 - __builtin_clz(n); t.assign(2*n, 0); d.assign(n, 0);}",
		"    void apply(int i, T v) {",
		"        t[i]+=v;",
		"        if (i < n) d[i]+=v;",
		"    }",
		"    void rebuild(int i) {",
		"        while (i > 1) i>>=1, t[i] = merge(t[i << 1], t[i << 1|1]) + d[i];",
		"    }",
		"    void push(int i) {",
		"        for (int j = h; j > 0; j--) {",
		"            int k = i >> j;",
		"            if (d[k] != 0) {",
		"                apply(k << 1, d[k]); apply(k << 1|1, d[k]);",
		"                d[k] = 0;",
		"            }",
		"        }",
		"    }",
		"    void set(int l, int r, T v) {",
		"        r++;",
		"        l+=n; r+=n;",
		"        int L = l, R = r;",
		"        for (; l < r; l>>=1, r>>=1) {",
		"            if (l & 1) apply(l++, v);",
		"            if (r & 1) apply(--r, v);",
		"        }",
		"        rebuild(L); rebuild(R - 1);",
		"    }",
		"    void build(const vector<T> &a) {",
		"        for (int i = 0; i < n; i++) set(i, i, a[i]);",
		"    }",
		"    T get(int l, int r) {",
		"        r++;",
		"        l+=n; r+=n;",
		"        push(l); push(r - 1);",
		"        T x = numeric_limits<T>::max();",
		"        for (; l < r; l>>=1, r>>=1) {",
		"            if (l & 1) x = merge(x, t[l++]);",
		"            if (r & 1) x = merge(x, t[--r]);",
		"        }",
		"        return x;",
		"    }",
		"};"
	],
	"description": "segtree_lazy_min"
	},
	"segtree_recursive": {
	"prefix": "segtree_recursive",
	"body": [
		"template<class T>",
		"struct segtree_recursive {",
		"    int n;",
		"    vector<T> t;",
		"    T neutral = 0;",
		"    T merge(T a, T b) {return a + b;}",
		"    void init(int N) {n = N; t.resize(4*n);}",
		"    void build(const vector<T> &a, int x, int lx, int rx) {",
		"        if (lx == rx) {",
		"            t[x] = a[lx];",
		"            return;",
		"        }",
		"        int m = (lx + rx) >> 1;",
		"        build(a, x << 1, lx, m);",
		"        build(a, x << 1|1, m + 1, rx);",
		"        t[x] = merge(t[x << 1], t[x << 1|1]);",
		"    }",
		"    void set(int i, T v, int x, int lx, int rx) {",
		"        if (lx == rx) {",
		"            t[x] = v;",
		"            return;",
		"        }",
		"        int m = (lx + rx) >> 1;",
		"        if (i <= m) set(i, v, x << 1, lx, m);",
		"        else set(i, v, x << 1|1, m + 1, rx);",
		"        t[x] = merge(t[x << 1], t[x << 1|1]);",
		"    }",
		"    T get(int l, int r, int x, int lx, int rx) {",
		"        if (lx > r || rx < l) return neutral;",
		"        if (lx >= l && rx <= r) return t[x];",
		"        int m = (lx + rx) >> 1;",
		"        return merge(get(l, r, x << 1, lx, m), get(l, r, x << 1|1, m + 1, rx));",
		"    }",
		"    void build(const vector<T> &a) {build(a, 1, 1, n);}",
		"    void set(int i, T v) {set(i, v, 1, 1, n);}",
		"    T get(int l, int r) {return get(l, r, 1, 1, n);}",
		"};"
	],
	"description": "segtree_recursive"
	},
	"segtree_lazy_min_recursive": {
	"prefix": "segtree_lazy_min_recursive",
	"body": [
		"template<class T>",
		"struct segtree_lazy_min_recursive {",
		"    int n;",
		"    vector<T> t, la;",
		"    T neutral = numeric_limits<T>::max();",
		"    T merge(T a, T b) {return min(a, b);}",
		"    void init(int N) {",
		"        n = N;",
		"        t.resize(4*n);",
		"        la.resize(4*n);",
		"    }",
		"    void build(const vector<T> &a, int x, int lx, int rx) {",
		"        if (lx == rx) {",
		"            t[x] = a[lx];",
		"            return;",
		"        }",
		"        int m = (lx + rx) >> 1;",
		"        build(a, x << 1, lx, m);",
		"        build(a, x << 1|1, m + 1, rx);",
		"        t[x] = merge(t[x << 1], t[x << 1|1]);",
		"    }",
		"    void down(int i) {",
		"        t[i << 1]+=la[i], t[i << 1|1]+=la[i];",
		"        la[i << 1]+=la[i], la[i << 1|1]+=la[i];",
		"        la[i] = 0;",
		"    }",
		"    void set(int l, int r, int x, int lx, int rx, T d) {",
		"        if (lx > r || rx < l) return;",
		"        if (lx >= l && rx <= r) {t[x]+=d; la[x]+=d; return;}",
		"        down(x);",
		"        int m = (lx + rx) >> 1;",
		"        set(l, r, x << 1, lx, m, d);",
		"        set(l, r, x << 1|1, m + 1, rx, d);",
		"        t[x] = merge(t[x << 1], t[x << 1|1]);",
		"    }",
		"    T get(int l, int r, int x, int lx, int rx) {",
		"        if (lx > r || rx < l) return neutral;",
		"        if (lx >= l && rx <= r) return t[x];",
		"        down(x);",
		"        int m = (lx + rx) >> 1;",
		"        return merge(get(l, r, x << 1, lx, m), get(l, r, x << 1|1, m + 1, rx));",
		"    }",
		"    void build(const vector<T> &a) {build(a, 1, 1, n);}",
		"    void set(int l, int r, T d) {set(l, r, 1, 1, n, d);}",
		"    T get(int l, int r) {return get(l, r, 1, 1, n);}",
		"};"
	],
	"description": "segtree_lazy_min_recursive"
	},
	"segtree_lazy_max_recursive": {
	"prefix": "segtree_lazy_max_recursive",
	"body": [
		"template<class T>",
		"struct segtree_lazy_max_recursive {",
		"    int n;",
		"    vector<T> t, la;",
		"    T neutral = numeric_limits<T>::min();",
		"    T merge(T a, T b) {return max(a, b);}",
		"    void init(int N) {",
		"        n = N;",
		"        t.resize(4*n);",
		"        la.resize(4*n);",
		"    }",
		"    void build(const vector<T> &a, int x, int lx, int rx) {",
		"        if (lx == rx) {",
		"            t[x] = a[lx];",
		"            return;",
		"        }",
		"        int m = (lx + rx) >> 1;",
		"        build(a, x << 1, lx, m);",
		"        build(a, x << 1|1, m + 1, rx);",
		"        t[x] = merge(t[x << 1], t[x << 1|1]);",
		"    }",
		"    void down(int i) {",
		"        t[i << 1]+=la[i], t[i << 1|1]+=la[i];",
		"        la[i << 1]+=la[i], la[i << 1|1]+=la[i];",
		"        la[i] = 0;",
		"    }",
		"    void set(int l, int r, int x, int lx, int rx, T d) {",
		"        if (lx > r || rx < l) return;",
		"        if (lx >= l && rx <= r) {t[x]+=d; la[x]+=d; return;}",
		"        down(x);",
		"        int m = (lx + rx) >> 1;",
		"        set(l, r, x << 1, lx, m, d);",
		"        set(l, r, x << 1|1, m + 1, rx, d);",
		"        t[x] = merge(t[x << 1], t[x << 1|1]);",
		"    }",
		"    T get(int l, int r, int x, int lx, int rx) {",
		"        if (lx > r || rx < l) return neutral;",
		"        if (lx >= l && rx <= r) return t[x];",
		"        down(x);",
		"        int m = (lx + rx) >> 1;",
		"        return merge(get(l, r, x << 1, lx, m), get(l, r, x << 1|1, m + 1, rx));",
		"    }",
		"    void build(const vector<T> &a) {build(a, 1, 1, n);}",
		"    void set(int l, int r, T d) {set(l, r, 1, 1, n, d);}",
		"    T get(int l, int r) {return get(l, r, 1, 1, n);}",
		"};"
	],
	"description": "segtree_lazy_min_recursive"
	},
	"segtree_lazy_sum_recursive": {
	"prefix": "segtree_lazy_sum_recursive",
	"body": [
		"template<class T>",
		"struct segtree_lazy_sum_recursive {",
		"    int n;",
		"    vector<T> t, la;",
		"    T neutral = 0;",
		"    T merge(T a, T b) {return a + b;}",
		"    void init(int N) {",
		"        n = N;",
		"        t.resize(4*n);",
		"        la.resize(4*n);",
		"    }",
		"    void build(const vector<T> &a, int x, int lx, int rx) {",
		"        if (lx == rx) {",
		"            t[x] = a[lx];",
		"            return;",
		"        }",
		"        int m = (lx + rx) >> 1;",
		"        build(a, x << 1, lx, m);",
		"        build(a, x << 1|1, m + 1, rx);",
		"        t[x] = merge(t[x << 1], t[x << 1|1]);",
		"    }",
		"    void down(int i, int l, int r) {",
		"        T k = la[i];",
		"        int m = (l + r) >> 1;",
		"        if (k != 0) {",
		"            t[i << 1]+=k*(m - l + 1);",
		"            t[i << 1|1]+=k*(r - m);",
		"            la[i << 1]+=k; la[i << 1|1]+=k;",
		"            la[i] = 0;",
		"        }",
		"    }",
		"    void set(int l, int r, int x, int lx, int rx, T d) {",
		"        if (lx > r || rx < l) return;",
		"        if (lx >= l && rx <= r) {t[x]+=d*(rx - lx + 1); la[x]+=d; return;}",
		"        down(x, lx, rx);",
		"        int m = (lx + rx) >> 1;",
		"        set(l, r, x << 1, lx, m, d);",
		"        set(l, r, x << 1|1, m + 1, rx, d);",
		"        t[x] = merge(t[x << 1], t[x << 1|1]);",
		"    }",
		"    T get(int l, int r, int x, int lx, int rx) {",
		"        if (lx > r || rx < l) return neutral;",
		"        if (lx >= l && rx <= r) return t[x];",
		"        down(x, lx, rx);",
		"        int m = (lx + rx) >> 1;",
		"        return merge(get(l, r, x << 1, lx, m), get(l, r, x << 1|1, m + 1, rx));",
		"    }",
		"    void build(const vector<T> &a) {build(a, 1, 1, n);}",
		"    void set(int l, int r, T d) {set(l, r, 1, 1, n, d);}",
		"    T get(int l, int r) {return get(l, r, 1, 1, n);}",
		"};"
	],
	"description": "segtree_lazy_sum_recursive"
	},
	"segtree_assign": {
	"prefix": "segtree_assign",
	"body": [
		"template<class T>",
		"struct segtree_assign {",
		"    int n;",
		"    vector<T> t;",
		"    vector<bool> c;",
		"    void init(int N) {",
		"        n = N;",
		"        t.resize(4*n);",
		"        c.resize(4*n);",
		"    }",
		"    void down(int i) {",
		"        if (c[i]) {",
		"            t[i << 1] = t[i << 1|1] = t[i];",
		"            c[i << 1] = c[i << 1|1] = 1;",
		"            c[i] = 0;",
		"        }",
		"    }",
		"    void set(int l, int r, int x, int lx, int rx, T d) {",
		"        if (lx > r || rx < l) return;",
		"        if (lx >= l && rx <= r) {",
		"            t[x] = d;",
		"            c[x] = 1;",
		"            return;",
		"        }",
		"        down(x);",
		"        int m = (lx + rx) >> 1;",
		"        set(l, r, x << 1, lx, m, d);",
		"        set(l, r, x << 1|1, m + 1, rx, d);",
		"    }",
		"    T get(int i, int x, int lx, int rx) {",
		"        if (lx == rx) return t[x];",
		"        down(x);",
		"        int m = (lx + rx) >> 1;",
		"        if (i <= m) return get(i, x << 1, lx, m);",
		"        return get(i, x << 1|1, m + 1, rx);",
		"    }",
		"    void set(int l, int r, T d) {set(l, r, 1, 1, n, d);}",
		"    T get(int i) {return get(i, 1, 1, n);}",
		"};"
	],
	"description": "segtree_assign"
	},
	"segtree_lazy_assign": {
	"prefix": "segtree_lazy_assign",
	"body": [
		"template<class T>",
		"struct segtree_lazy_assign {",
		"    int n;",
		"    vector<T> t, la;",
		"    void init(int N) {",
		"        n = N;",
		"        t.resize(4*n);",
		"        la.resize(4*n, -1);",
		"    }",
		"    void down(int i, int l, int r) {",
		"        int m = (l + r) >> 1;",
		"        if (la[i] != -1) {",
		"            t[i << 1] = la[i]*(m - l + 1);",
		"            t[i << 1|1] = la[i]*(r - m);",
		"            la[i << 1] = la[i << 1|1] = la[i];",
		"            la[i] = -1;",
		"        }",
		"    }",
		"    void set(int l, int r, int x, int lx, int rx, T d) {",
		"        if (lx > r || rx < l) return;",
		"        if (lx >= l && rx <= r) {",
		"            t[x] = d*(rx - lx + 1);",
		"            la[x] = d;",
		"            return;",
		"        }",
		"        down(x, lx, rx);",
		"        int m = (lx + rx) >> 1;",
		"        set(l, r, x << 1, lx, m, d);",
		"        set(l, r, x << 1|1, m + 1, rx, d);",
		"        t[x] = t[x << 1] + t[x << 1|1];",
		"    }",
		"    T get(int l, int r, int x, int lx, int rx) {",
		"        if (lx > r || rx < l) return 0;",
		"        if (lx >= l && rx <= r) return t[x];",
		"        down(x, lx, rx);",
		"        int m = (lx + rx) >> 1;",
		"        return get(l, r, x << 1, lx, m) + get(l, r, x << 1|1, m + 1, rx);",
		"    }",
		"    void set(int l, int r, T d) {set(l, r, 1, 1, n, d);}",
		"    T get(int l, int r) {return get(l, r, 1, 1, n);}",
		"};"
	],
	"description": "segtree_lazy_assign"
	},
	"sparse_min": {
	"prefix": "sparse_min",
	"body": [
		"template<class T>",
		"struct sparse_min {",
		"    int n;",
		"    vector<vector<T>> s;",
		"    T merge(T a, T b) {return min(a, b);}",
		"    void init(int N) {",
		"        n = N;",
		"        int k = Log2(n) + 2;",
		"        s.assign(k, vector<T>(n + 3));",
		"    }",
		"    void build(const vector<T> &a) {",
		"        for (int i = 0; i < n; i++) s[0][i] = a[i];",
		"        for (int j = 1; (1 << j) <= n; j++) {",
		"            for (int i = 0; i <= n - (1 << j); i++) {",
		"                s[j][i] = merge(s[j - 1][i], s[j - 1][i + (1 << (j - 1))]);",
		"            }",
		"        }",
		"    }",
		"    T get(int l, int r) {",
		"        int i = Log2(r - l + 1);",
		"        return merge(s[i][l], s[i][r - (1 << i) + 1]);",
		"    }",
		"};"
	],
	"description": "sparse_min"
	},
	"sparse_max": {
	"prefix": "sparse_max",
	"body": [
		"template<class T>",
		"struct sparse_max {",
		"    int n;",
		"    vector<vector<T>> s;",
		"    T merge(T a, T b) {return max(a, b);}",
		"    void init(int N) {",
		"        n = N;",
		"        int k = Log2(n) + 2;",
		"        s.assign(k, vector<T>(n + 3));",
		"    }",
		"    void build(const vector<T> &a) {",
		"        for (int i = 0; i < n; i++) s[0][i] = a[i];",
		"        for (int j = 1; (1 << j) <= n; j++) {",
		"            for (int i = 0; i <= n - (1 << j); i++) {",
		"                s[j][i] = merge(s[j - 1][i], s[j - 1][i + (1 << (j - 1))]);",
		"            }",
		"        }",
		"    }",
		"    T get(int l, int r) {",
		"        int i = Log2(r - l + 1);",
		"        return merge(s[i][l], s[i][r - (1 << i) + 1]);",
		"    }",
		"};"
	],
	"description": "sparse_max"
	},
	"sparse_gcd": {
	"prefix": "sparse_gcd",
	"body": [
		"template<class T>",
		"struct sparse_gcd {",
		"    int n;",
		"    vector<vector<T>> s;",
		"    T merge(T a, T b) {return gcd(a, b);}",
		"    void init(int N) {",
		"        n = N;",
		"        int k = Log2(n) + 2;",
		"        s.assign(k, vector<T>(n + 3));",
		"    }",
		"    void build(const vector<T> &a) {",
		"        for (int i = 0; i < n; i++) s[0][i] = a[i];",
		"        for (int j = 1; (1 << j) <= n; j++) {",
		"            for (int i = 0; i <= n - (1 << j); i++) {",
		"                s[j][i] = merge(s[j - 1][i], s[j - 1][i + (1 << (j - 1))]);",
		"            }",
		"        }",
		"    }",
		"    T get(int l, int r) {",
		"        int i = Log2(r - l + 1);",
		"        return merge(s[i][l], s[i][r - (1 << i) + 1]);",
		"    }",
		"};"
	],
	"description": "sparse_max"
	},
	"fraction": {
	"prefix": "fraction",
	"body": [
		"template<class T>",
		"struct fraction {",
		"    T a, b;",
		"    fraction(T x = 0, T y = 1) {",
		"        assert(y != 0);",
		"        a = x; b = y;",
		"        T c = __gcd(abs(a), abs(b));",
		"        a/=c;",
		"        b/=c;",
		"        if (b < 0) a = -a, b = -b;",
		"    }",
		"    friend istream& operator>>(istream& in, fraction &f) {in >> f.a >> f.b; return in;}",
		"    friend ostream& operator<<(ostream& out, fraction f) {out << f.a << '/' << f.b; return out;}",
		"    bool operator==(fraction f) const {return a == f.a && b == f.b;}",
		"    bool operator<(fraction f) const {return a*f.b < b*f.a;}",
		"    bool operator<=(fraction f) const {return a*f.b <= b*f.a;}",
		"    bool operator>(fraction f) const {return a*f.b > b*f.a;}",
		"    bool operator>=(fraction f) const {return a*f.b >= b*f.a;}",
		"    fraction operator+(fraction f) const {return fraction(a*f.b + b*f.a, b*f.b);}",
		"    fraction operator-(fraction f) const {return fraction(a*f.b - b*f.a, b*f.b);}",
		"    fraction operator*(fraction f) const {return fraction(a*f.a, b*f.b);}",
		"    fraction operator/(fraction f) const {return fraction(a*f.b, b*f.a);}",
		"    fraction operator+(T n) const {return fraction(a + b*n, b);}",
		"    fraction operator-(T n) const {return fraction(a - b*n, b);}",
		"    fraction operator*(T n) const {return fraction(a*n, b);}",
		"    fraction operator/(T n) const {return fraction(a, b*n);}",
		"};",
		"using F = fraction<ll>;"
	],
	"description": "fraction"
	},
	"matrix": {
	"prefix": "matrix",
	"body": [
		"template<class T>",
		"struct matrix {",
		"    int n, m;",
		"    vector<vector<T>> a;",
		"    matrix(int N = 0, int M = 0) {",
		"        n = N; m = M;",
		"        a.assign(n, vector<T>(m));",
		"    }",
		"    matrix(const vector<vector<T>> &b) {",
		"        a = b;",
		"        n = sz(a); m = sz(a[0]);",
		"    }",
		"    friend istream& operator>>(istream& in, matrix &b) {in >> b.a; return in;}",
		"    friend ostream& operator<<(ostream& out, const matrix &b) {out << b.a; return out;}",
		"    static matrix single(int k) {",
		"        matrix b(k, k);",
		"        while (k--) b.a[k][k] = 1;",
		"        return b;",
		"    }",
		"    matrix operator*(const matrix &b) {",
		"        matrix c(n, b.m);",
		"        for (int i = 0; i < n; i++) {",
		"            for (int k = 0; k < m; k++) {",
		"                for (int j = 0; j < b.m; j++) {",
		"                    c.a[i][j]+=a[i][k]*b.a[k][j];",
		"                    if (c.a[i][j] >= mod) c.a[i][j]%=mod;",
		"                }",
		"            }",
		"        }",
		"        return c;",
		"    }",
		"    matrix operator+(const matrix &b) {",
		"        matrix c(n, m);",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) {",
		"                c.a[i][j] = a[i][j] + b.a[i][j];",
		"                if (c.a[i][j] >= mod) c.a[i][j]-=mod;",
		"            }",
		"        }",
		"        return c;",
		"    }",
		"    matrix operator-(const matrix &b) {",
		"        matrix c(n, m);",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) {",
		"                c.a[i][j] = a[i][j] - b.a[i][j];",
		"                if (c.a[i][j] < 0) c.a[i][j]+=mod;",
		"            }",
		"        }",
		"        return c;",
		"    }",
		"    matrix pow(ll k) {",
		"        matrix x = single(n), b = a;",
		"        for (; k; k>>=1, b = b*b) {",
		"            if (k & 1) x = x*b;",
		"        }",
		"        return x;",
		"    }",
		"};",
		"using mat = matrix<ll>;"
	],
	"description": "matrix"
	},
	"cht_kactl": {
	"prefix": "cht_kactl",
	"body": [
		"struct Line {",
		"    mutable ll k, m, p;",
		"    bool operator<(const Line& o) const { return k < o.k; }",
		"    bool operator<(ll x) const { return p < x; }",
		"};",
		"struct LineContainer : multiset<Line, less<>> {",
		"    static const ll inf = 2e18;",
		"    ll div(ll a, ll b) {",
		"        return a/b - ((a^b) < 0 && a % b); }",
		"    bool isect(iterator x, iterator y) {",
		"        if (y == end()) return x->p = inf, 0;",
		"        if (x->k == y->k) x->p = x->m > y->m ? inf: -inf;",
		"        else x->p = div(y->m - x->m, x->k - y->k);",
		"        return x->p >= y->p;",
		"    }",
		"    void add(ll k, ll m) {",
		"        auto z = insert({k, m, 0}), y = z++, x = y;",
		"        while (isect(y, z)) z = erase(z);",
		"        if (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
		"        while ((y = x) != begin() && (--x)->p >= y->p) isect(x, erase(y));",
		"    }",
		"    ll query(ll x) {",
		"        auto l = *lower_bound(x);",
		"        return l.k*x + l.m;",
		"    }",
		"};"
	],
	"description": "cht_kactl"
	},
	"cht_max": {
	"prefix": "cht_max",
	"body": [
		"struct cht_max {",
		"    vll a, b;",
		"    int id = 0;",
		"    ll eval(int i, ll x) {return a[i]*x + b[i];}",
		"    void init() {id = 0; a.clear(); b.clear();}",
		"    bool bad(int j) {",
		"        int i = j - 1, k = j + 1;",
		"        return (int128)(b[k] - b[i])*(a[i] - a[j]) > (int128)(b[j] - b[i])*(a[i] - a[k]);",
		"    }",
		"    void add(ll x, ll y) {",
		"        a.push_back(x); b.push_back(y);",
		"        while (sz(a) > 2 && bad(sz(a) - 2)) a.erase(a.end() - 2), b.erase(b.end() - 2);",
		"    }",
		"    ll query(ll x) {",
		"        id = min(id, sz(a) - 1);",
		"        while (id + 1 < sz(a) && eval(id + 1, x) > eval(id, x)) id++;",
		"        return eval(id, x);",
		"    }",
		"};"
	],
	"description": "cht_max"
	},
	"cht_min": {
	"prefix": "cht_min",
	"body": [
		"struct cht_min {",
		"    vll a, b;",
		"    int id = 0;",
		"    ll eval(int i, ll x) {return a[i]*x + b[i];}",
		"    bool bad(int j) {",
		"        int i = j - 1, k = j + 1;",
		"        return (int128)(b[k] - b[i])*(a[i] - a[j]) < (int128)(b[j] - b[i])*(a[i] - a[k]);",
		"    }",
		"    void add(ll x, ll y) {",
		"        a.pb(x); b.pb(y);",
		"        while (sz(a) > 2 && bad(sz(a) - 2)) a.erase(a.end() - 2), b.erase(b.end() - 2);",
		"    }",
		"    ll query(ll x) {",
		"        while (id + 1 < sz(a) && eval(id, x) > eval(id + 1, x)) id++;",
		"        return eval(id, x);",
		"    }",
		"};"
	],
	"description": "cht_min"
	},
	"cht_deque": {
	"prefix": "cht_deque",
	"body": [
		"struct Line {",
		"    ll k, m, p;",
		"    bool operator<(const Line& o) const { return k < o.k; }",
		"    bool operator<(ll x) const { return p < x; }",
		"    ll eval(ll x) const { return k * x + m; }",
		"};",
		"deque<Line> hull;",
		"ll inf = LLONG_MAX;",
		"ll division(ll a, ll b) {",
		"    return a / b - ((a < 0) != (b < 0) && a % b);",
		"}",
		"bool isect(Line &x, const Line &y) {",
		"    if (x.k == y.k) x.p = x.m > y.m ? inf : -inf;",
		"    else x.p = division(y.m - x.m, x.k - y.k);",
		"    return x.p >= y.p;",
		"}",
		"void add(ll k, ll m) {",
		"    Line L = {k, m, 0};",
		"    while ((int) hull.size() >= 2 && (isect(L, hull.back()),",
		"        isect(hull.back(), hull[(int) hull.size() - 2]), L.p < hull.back().p))",
		"        hull.pop_back();",
		"    hull.push_back(L);",
		"}",
		"ll query(ll x) {",
		"    while ((int) hull.size() >= 2 && hull[0].eval(x) >= hull[1].eval(x))",
		"        hull.pop_front();",
		"    return hull[0].eval(x);",
		"}",
		""
	],
	"description": "cht_deque"
	},
	"dsu": {
	"prefix": "dsu",
	"body": [
		"struct dsu {",
		"    vector<int> p, s;",
		"    int c;",
		"    dsu(int n) {",
		"        p.resize(n);",
		"        s.assign(n, 1);",
		"        iota(all(p), 0);",
		"        c = n;",
		"    }",
		"    int get(int u) {return u == p[u] ? u: p[u] = get(p[u]);}",
		"    bool merge(int u, int v) {",
		"        u = get(u), v = get(v);",
		"        if (u != v) {",
		"            if (s[u] < s[v]) swap(u, v);",
		"            p[v] = u;",
		"            s[u]+=s[v];",
		"            c--;",
		"            return 1;",
		"        }",
		"        return 0;",
		"    }",
		"    bool join(int u, int v) {",
		"        return get(u) == get(v);",
		"    }",
		"};"
	],
	"description": "dsu"
	},
	"bignum": {
	"prefix": "bignum",
	"body": [
		"struct bignum {",
		"    string s;",
		"    bignum() {",
		"        this->s = \"0\";",
		"    }",
		"    bignum(string a) {",
		"        s = a;",
		"    }",
		"    bignum(int a) {",
		"        s = to_string(a);",
		"    }",
		"    bignum(ll a) {",
		"        s = to_string(a);",
		"    }",
		"    friend istream &operator>>(istream &is, bignum &a) {",
		"        is >> a.s;",
		"        return is;",
		"    }",
		"    friend ostream &operator<<(ostream &os, const bignum &a) {",
		"        os << a.s;",
		"        return os;",
		"    }",
		"    bool operator<(const bignum &a) const {",
		"        if (sz(s) < sz(a.s)) return 1;",
		"        if (sz(s) > sz(a.s)) return 0;",
		"        return s < a.s;",
		"    }",
		"    bool operator>(const bignum &a) const {",
		"        if (sz(s) > sz(a.s)) return 1;",
		"        if (sz(s) < sz(a.s)) return 0;",
		"        return s > a.s;",
		"    }",
		"    bool operator==(const bignum &a) {",
		"        return s == a.s;",
		"    }",
		"    bool operator!=(const bignum &a) {",
		"        return s != a.s;",
		"    }",
		"    bool operator<=(const bignum &a) {",
		"        if (sz(s) < sz(a.s)) return 1;",
		"        if (sz(s) > sz(a.s)) return 0;",
		"        return s <= a.s;",
		"    }",
		"    bool operator>=(const bignum &a) {",
		"        if (sz(s) > sz(a.s)) return 1;",
		"        if (sz(s) < sz(a.s)) return 0;",
		"        return s >= a.s;",
		"    }",
		"    bignum operator+(const bignum &a) {",
		"        string x = \"\";",
		"        int m = s.size(), n = a.s.size();",
		"        int d = abs(m - n), c = 0;",
		"        for (int i = min(m, n) - 1; i >= 0; i--) {",
		"            int sum = c;",
		"            if (m < n) sum+=s[i] - '0' + a.s[i + d] - '0';",
		"            else sum+=s[i + d] - '0' + a.s[i] - '0';",
		"            x+=sum % 10 + '0';",
		"            c = sum/10;",
		"        }",
		"        if (m < n) {",
		"            for (int i = n - m - 1; i >= 0; i--) {",
		"                int sum = ((a.s[i] - '0') + c);",
		"                x+=sum % 10 + '0';",
		"                c = sum/10;",
		"            }",
		"        } else {",
		"            for (int i = m - n - 1; i >= 0; i--) {",
		"                int sum = ((s[i] - '0') + c);",
		"                x+=sum % 10 + '0';",
		"                c = sum/10;",
		"            }",
		"        }",
		"        if (c) x+=c + '0';",
		"        while (x.size() > 1 && x.back() == '0') x.pop_back();",
		"        reverse(x.begin(), x.end());",
		"        return bignum(x);",
		"    }",
		"    bignum operator-(const bignum &a) {",
		"        string x = \"\";",
		"        int m = s.size(), n = a.s.size();",
		"        int d = m - n, c = 0;",
		"        for (int i = n - 1; i >= 0; i--) {",
		"            int sub = ((s[i + d] - '0') - (a.s[i] - '0') - c);",
		"            if (sub < 0) {",
		"                sub = sub + 10;",
		"                c = 1;",
		"            } else c = 0;",
		"            x+=sub + '0';",
		"        }",
		"        for (int i = m - n - 1; i >= 0; i--) {",
		"            if (s[i] == '0' && c) {",
		"                x+='9';",
		"                continue;",
		"            }",
		"            int sub = ((s[i] - '0') - c);",
		"            if (i > 0 || sub > 0) x+=sub + '0';",
		"            c = 0;",
		"        }",
		"        while (x.size() > 1 && x.back() == '0') x.pop_back();",
		"        reverse(x.begin(), x.end());",
		"        return bignum(x);",
		"    }",
		"    bignum operator*(const bignum &a) {",
		"        int m = s.size(), n = a.s.size();",
		"        string x(m + n, '0');",
		"        int p = 0;",
		"        for (int i = m - 1; i >= 0; i--) {",
		"            int c = 0, q = 0;",
		"            for (int j = n - 1; j >= 0; j--) {",
		"                int sum = (s[i] - '0')*(a.s[j] - '0') + x[p + q] - '0' + c;",
		"                x[p + q] = sum % 10 + '0';",
		"                c = sum/10;",
		"                q++;",
		"            }",
		"            if (c > 0) x[p + q]+=c;",
		"            p++;",
		"        }",
		"        while (x.size() > 1 && x.back() == '0') x.pop_back();",
		"        reverse(x.begin(), x.end());",
		"        return bignum(x);",
		"    }",
		"};"
	],
	"description": "bignum"
	},
	"manacher": {
	"prefix": "manacher",
	"body": [
		"vi manacher_odd(string s) {",
		"    int n = sz(s);",
		"    s = \"!\" + s + \"@\";",
		"    vi p(n + 2);",
		"    int l = 1, r = 1;",
		"    FOR(i,1,n){",
		"        p[i] = max(0, min(r - i, p[l + r - i]));",
		"        while (s[i - p[i]] == s[i + p[i]]) p[i]++;",
		"        if (i + p[i] > r) l = i - p[i], r = i + p[i];",
		"    }",
		"    p.erase(p.begin()); p.pop_back();",
		"    return p;",
		"}",
		"vi manacher(const string &s) {",
		"    string t;",
		"    trav(i,s) t+='#', t+=i;",
		"    t+='#';",
		"    vi a = manacher_odd(t);",
		"    a.erase(a.begin()); a.pop_back();",
		"    return a;",
		"}"
	],
	"description": "manacher"
	},
	"z_function": {
	"prefix": "z_function",
	"body": [
		"vi z_function(const string &s) {",
		"    int n = sz(s), l = 0, r = 0;",
		"    vi z(n);",
		"    For(i,1,n){",
		"        if (i < r) z[i] = min(r - i, z[i - l]);",
		"        while (s[z[i]] == s[i + z[i]]) z[i]++;",
		"        if (i + z[i] > r) l = i, r = i + z[i];",
		"    }",
		"    return z;",
		"}"
	],
	"description": "z_function"
	},
	"kmp": {
	"prefix": "kmp",
	"body": [
		"vi prefix_function(const string &s) {",
		"    int n = sz(s);",
		"    vi p(n);",
		"    For(i,1,n){",
		"        int j = p[i - 1];",
		"        while (j > 0 && s[j] != s[i]) j = p[j - 1];",
		"        if (s[i] == s[j]) j++;",
		"        p[i] = j;",
		"    }",
		"    return p;",
		"}",
		"vi kmp(const string &s, const string &t) {",
		"    int n = sz(s), m = sz(t);",
		"    vi p = prefix_function(s);",
		"    int j = 0;",
		"    vi a;",
		"    For(i,0,m){",
		"        while (j > 0 && t[i] != s[j]) j = p[j - 1];",
		"        if (t[i] == s[j]) j++;",
		"        if (j == n) a.push_back(i - n + 1);",
		"    }",
		"    return a;",
		"}",
		"vvi automaton(const string &s) {",
		"    vi p = prefix_function(s);",
		"    int n = sz(s);",
		"    vvi a(n + 1, vi(26));",
		"    FOR(i,0,n){",
		"        For(c,0,26){",
		"            if (i > 0 && c + 'a' != s[i]) a[i][c] = a[p[i - 1]][c];",
		"            else a[i][c] = i + (c + 'a' == s[i]);",
		"        }",
		"    }",
		"    For(c,0,26) a[n][c] = a[p[n - 1]][c];",
		"    return a;",
		"}"
	],
	"description": "kmp"
	},
	"trie_number": {
	"prefix": "trie_number",
	"body": [
		"struct trie {",
		"    struct node {",
		"        int c[2], cnt, ex;",
		"    };",
		"    vector<node> a;",
		"    int k, l;",
		"    void init(int n) {",
		"        a.resize(n);",
		"        k = 0; l = 30;",
		"        memset(a[0].c, -1, sizeof(a[0].c));",
		"        a[0].cnt = a[0].ex = 0;",
		"    }",
		"    int new_node() {",
		"        k++;",
		"        memset(a[k].c, -1, sizeof(a[k].c));",
		"        a[k].cnt = a[k].ex = 0;",
		"        return k;",
		"    }",
		"    void add(int x) {",
		"        int p = 0;",
		"        for (int i = l; i >= 0; i--) {",
		"            int j = (x >> i) & 1;",
		"            if (a[p].c[j] == -1) a[p].c[j] = new_node();",
		"            p = a[p].c[j];",
		"            a[p].cnt++;",
		"        }",
		"        a[p].ex++;",
		"    }",
		"    void del(int x) {",
		"        int p = 0;",
		"        for (int i = l; i >= 0; i--) {",
		"            int j = (x >> i) & 1;",
		"            int t = a[p].c[j];",
		"            a[t].cnt--;",
		"            if (a[t].cnt == 0) {",
		"                a[p].c[j] = -1;",
		"                return;",
		"            }",
		"            p = t;",
		"        }",
		"        a[p].ex--;",
		"    }",
		"    int max_xor(int n) {",
		"        int p = 0, x = 0;",
		"        for (int i = l; i >= 0; i--) {",
		"            int j = (n >> i) & 1;",
		"            if (a[p].c[j ^ 1] != -1) {",
		"                x+=1 << i;",
		"                p = a[p].c[j ^ 1];",
		"            } else p = a[p].c[j];",
		"        }",
		"        return x;",
		"    }",
		"};"
	],
	"description": "trie_number"
	},
	"combinatorics": {
	"prefix": "combinatorics",
	"body": [
		"const int N = 1e6 + 3;",
		"ll fact[N], inv[N];",
		"void pre() {",
		"    fact[0] = 1;",
		"    For(i,1,N) fact[i] = fact[i - 1]*i % mod;",
		"    inv[N - 1] = power(fact[N - 1], mod - 2, mod);",
		"    Fore(i,N-2,0) inv[i] = inv[i + 1]*(i + 1) % mod;",
		"}",
		"ll C(ll k, ll n) {",
		"    if (k > n) return 0;",
		"    return fact[n]*inv[k] % mod*inv[n - k] % mod;",
		"}"
	],
	"description": "combinatorics"
	},
	"gauss": {
	"prefix": "gauss",
	"body": [
		"vdo gauss(vvdo a) {",
		"    int n = sz(a); assert(sz(a[0]) == n + 1);",
		"    vi p(n);",
		"    for (int j = 0, i = 0; j < n && i < n; j++, i++) {",
		"        int t = i;",
		"        For(k,i,n){",
		"            if (abs(a[k][j]) > abs(a[t][j])) t = k;",
		"        }",
		"        if (abs(a[t][j]) < eps) continue;",
		"        FOR(k,j,n) swap(a[t][k], a[i][k]);",
		"        p[j] = i;",
		"        For(k,0,n){",
		"            if (k != i) {",
		"                double v = a[k][j]/a[i][j];",
		"                FOR(l,j,n) a[k][l]-=v*a[i][l];",
		"            }",
		"        }",
		"    }",
		"    vdo s(n);",
		"    For(i,0,n) s[i] = a[p[i]][n]/a[p[i]][i];",
		"    return s;",
		"}"
	],
	"description": "gauss"
	},
	"gauss_simple": {
	"prefix": "gauss_simple",
	"body": [
		"vdo gauss(vvdo a) {",
		"    int n = sz(a); assert(sz(a[0]) == n + 1);",
		"    for (int j = 0, i = 0; j < n && i < n; j++, i++) {",
		"        For(k,0,n){",
		"            if (k != i) {",
		"                double v = a[k][j]/a[i][j];",
		"                FOR(l,j,n) a[k][l]-=v*a[i][l];",
		"            }",
		"        }",
		"    }",
		"    vdo s(n);",
		"    For(i,0,n) s[i] = a[i][n]/a[i][i];",
		"    return s;",
		"}"
	],
	"description": "gauss_simple"
	},
	"flow": {
	"prefix": "flow",
	"body": [
		"struct Flow {",
		"    struct edge {",
		"        int u, v;",
		"        ll c, f;",
		"        edge(int x = 0, int y = 0, ll z = 0) {u = x; v = y; c = z; f = 0;}",
		"    };",
		"    ll inf;",
		"    int n, m, s, t;",
		"    vector<edge> e;",
		"    vector<vector<int>> a;",
		"    vector<int> l, p;",
		"    queue<int> q;",
		"    void init(int N, int S, int T) {",
		"        n = N; m = 0; s = S; t = T;",
		"        inf = 1e18;",
		"        a.assign(n, vector<int>()); l.assign(n, 0); p.assign(n, 0); e.clear();",
		"    }",
		"    void add(int u, int v, ll c) {",
		"        e.push_back(edge(u, v, c)); e.push_back(edge(v, u, 0));",
		"        a[u].push_back(m); a[v].push_back(m + 1);",
		"        m+=2;",
		"    }",
		"    bool bfs() {",
		"        while (!q.empty()) {",
		"            int u = q.front(); q.pop();",
		"            for (int i: a[u]) {",
		"                if (e[i].c == e[i].f || l[e[i].v] != -1) continue;",
		"                l[e[i].v] = l[u] + 1;",
		"                q.push(e[i].v); ",
		"            }",
		"        }",
		"        return l[t] != -1;",
		"    }",
		"    ll dfs(int u, ll push) {",
		"        if (push == 0 || u == t) return push;",
		"        for (; p[u] < sz(a[u]); p[u]++) {",
		"            int j = p[u], i = a[u][j], v = e[i].v;",
		"            if (l[u] + 1 != l[v] || e[i].c == e[i].f) continue;",
		"            ll x = dfs(v, min(push, e[i].c - e[i].f));",
		"            if (x == 0) continue;",
		"            e[i].f+=x; e[i^1].f-=x;",
		"            return x;",
		"        }",
		"        return 0;",
		"    }",
		"    ll max_flow() {",
		"        ll x = 0;",
		"        while (1) {",
		"            fill(all(l), -1);",
		"            l[s] = 0;",
		"            q.push(s);",
		"            if (!bfs()) break;",
		"            fill(all(p), 0);",
		"            while (ll push = dfs(s, inf)) x+=push;",
		"        }",
		"        return x;",
		"    }",
		"};"
	],
	"description": "flow"
	},
	"fft": {
	"prefix": "fft",
	"body": [
		"void fft(vcd &a, bool inv) {",
		"    int n = sz(a);",
		"    for (int i = 1, j = 0; i < n; i++) {",
		"        int b = n >> 1;",
		"        for (; j & b; b>>=1) j^=b;",
		"        j^=b;",
		"        if (i < j) swap(a[i], a[j]);",
		"    }",
		"    for (int k = 2; k <= n; k<<=1) {",
		"        double ang = 2*PI/k;",
		"        if (inv) ang = -ang;",
		"        cd t(cos(ang), sin(ang));",
		"        for (int i = 0; i < n; i+=k) {",
		"            cd w(1);",
		"            For(j,0,k>>1){",
		"                cd u = a[i + j], v = a[i + j + (k >> 1)]*w;",
		"                a[i + j] = u + v; a[i + j + (k >> 1)] = u - v;",
		"                w*=t;",
		"            }",
		"        }",
		"    }",
		"    if (inv) {",
		"        trav(i,a) i/=n;",
		"    }",
		"}",
		"vll mul(const vll &a, const vll &b) {",
		"    vcd c(all(a)), d(all(b));",
		"    int n = 1;",
		"    while (n < sz(c) + sz(d)) n<<=1;",
		"    c.resize(n); d.resize(n);",
		"    fft(c, 0); fft(d, 0);",
		"    For(i,0,n) c[i]*=d[i];",
		"    fft(c, 1);",
		"    vll f(n);",
		"    For(i,0,n) f[i] = round(c[i].real());",
		"    return f;",
		"}"
	],
	"description": "fft"
	},
	"fftmod": {
	"prefix": "fftmod",
	"body": [
		"#undef double",
		"typedef complex<double> CD;",
		"void fft(vector<CD> &a) {",
		"    int n = sz(a), L = 31 - __builtin_clz(n);",
		"    static vector<complex<long double>> R(2, 1);",
		"    static vector<CD> rt(2, 1);",
		"    for (static int k = 2; k < n; k *= 2) {",
		"        R.resize(n);",
		"        rt.resize(n);",
		"        auto x = polar(1.0L, acos(-1.0L) / k);",
		"        For(i,k,k<<1) rt[i] = R[i] = i & 1 ? R[i / 2] * x : R[i / 2];",
		"    }",
		"    vi rev(n);",
		"    For(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
		"    For(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
		"    for (int k = 1; k < n; k<<=1) {",
		"        for (int i = 0; i < n; i+=k << 1) {",
		"            For(j,0,k){",
		"                auto x = (double *)&rt[j + k], y = (double *)&a[i + j + k];",
		"                CD z(x[0] * y[0] - x[1] * y[1], x[0] * y[1] + x[1] * y[0]);",
		"                a[i + j + k] = a[i + j] - z;",
		"                a[i + j] += z;",
		"            }",
		"        }",
		"    }",
		"}",
		"template <int M> vll convMod(const vll &a, const vll &b) {",
		"    if (a.empty() || b.empty()) return {};",
		"    vll res(sz(a) + sz(b) - 1);",
		"    int B = 32 - __builtin_clz(sz(res)), n = 1 << B, cut = int(sqrt(M));",
		"    vector<CD> L(n), R(n), outs(n), outl(n);",
		"    For(i,0,sz(a)) L[i] = CD((int)a[i] / cut, (int)a[i] % cut);",
		"    For(i,0,sz(b)) R[i] = CD((int)b[i] / cut, (int)b[i] % cut);",
		"    fft(L), fft(R);",
		"    For(i,0,n) {",
		"        int j = -i & (n - 1);",
		"        outl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);",
		"        outs[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;",
		"    }",
		"    fft(outl), fft(outs);",
		"    For(i,0,sz(res)) {",
		"        ll av = (ll)(real(outl[i]) + .5), cv = (ll)(imag(outs[i]) + .5);",
		"        ll bv = (ll)(imag(outl[i]) + .5) + (ll)(real(outs[i]) + .5);",
		"        res[i] = ((av % M * cut + bv) % M * cut + cv) % M;",
		"    }",
		"    return res;",
		"}"
	],
	"description": "fftmod"
	},
	"ntt998244353": {
	"prefix": "ntt998244353",
	"body": [
		"const int rt = 15311432, invrt = 469870224, pw = 1 << 23;",
		"void ntt(vll &a, bool inv) {",
		"    int n = sz(a);",
		"    for (int i = 1, j = 0; i < n; i++) {",
		"        int b = n >> 1;",
		"        for (; j & b; b>>=1) j^=b;",
		"        j^=b;",
		"        if (i < j) swap(a[i], a[j]);",
		"    }",
		"    for (int l = 2; l <= n; l<<=1) {",
		"        ll t = inv ? invrt: rt;",
		"        for (int i = l; i < pw; i<<=1) t = t*t % mod2;",
		"        for (int i = 0; i < n; i+=l) {",
		"            ll w = 1;",
		"            For(j,0,l>>1){",
		"                ll u = a[i + j], v = a[i + j + (l >> 1)]*w % mod2;",
		"                a[i + j] = add(u, v, mod2); a[i + j + (l >> 1)] = sub(u, v, mod2);",
		"                w = w*t % mod2;",
		"            }",
		"        }",
		"    }",
		"    if (inv) {",
		"        ll m = power(n, mod2 - 2, mod2);",
		"        trav(i,a) i = i*m % mod2;",
		"    }",
		"}",
		"vll mulmod(vll a, vll b) {",
		"    int n = 1;",
		"    while (n < sz(a) + sz(b)) n<<=1;",
		"    a.resize(n); b.resize(n);",
		"    ntt(a, 0); ntt(b, 0);",
		"    For(i,0,n) a[i] = a[i]*b[i] % mod2;",
		"    ntt(a, 1);",
		"    return a;",
		"}"
	],
	"description": "ntt998244353"
	},
	"aho_corasick": {
	"prefix": "aho_corasick",
	"body": [
		"struct aho_corasick {",
		"    struct node {",
		"        int suf, ex, c[26];",
		"        int l;",
		"        node() {suf = ex = -1; l = 0; memset(c, -1, sizeof(c));}",
		"    };",
		"    vector<node> a{node()};",
		"    void add(const string &s, int j) {",
		"        int p = 0;",
		"        trav(k,s){",
		"            int i = k - 'a';",
		"            if (a[p].c[i] == -1) {",
		"                a[p].c[i] = sz(a);",
		"                a.pb(node());",
		"            }",
		"            p = a[p].c[i];",
		"        }",
		"        a[p].l++;",
		"    }",
		"    void build() {",
		"        queue<int> q; q.push(0);",
		"        while (sz(q)) {",
		"            int p = q.front(); q.pop();",
		"            int suf = a[p].suf;",
		"            if (p) {",
		"                if (a[suf].l) a[p].ex = suf;",
		"                else a[p].ex = a[suf].ex;",
		"            }",
		"            For(i,0,26){",
		"                int s = 0;",
		"                if (p) s = a[suf].c[i];",
		"                if (a[p].c[i] == -1) a[p].c[i] = s;",
		"                else {",
		"                    a[a[p].c[i]].suf = s;",
		"                    q.push(a[p].c[i]);",
		"                }",
		"            }",
		"        }",
		"    }",
		"    int count(int p) {",
		"        int t = 0;",
		"        for (int i = a[p].l ? p: a[p].ex; i != -1; i = a[i].ex) {",
		"            t+=a[i].l;",
		"        }",
		"        return t;",
		"    }",
		"};"
	],
	"description": "aho_corasick"
	},
	"suffix_array": {
	"prefix": "suffix_array",
	"body": [
		"vi suffix_array(string s) {",
		"    s+='$';",
		"    int n = sz(s);",
		"    vi p(n), c(n), f(max(n, 128));",
		"    trav(i,s) f[i]++;",
		"    partial_sum(all(f), f.begin());",
		"    For(i,0,n) p[--f[s[i]]] = i;",
		"    int cl = 1;",
		"    For(i,1,n){",
		"        if (s[p[i]] != s[p[i - 1]]) cl++;",
		"        c[p[i]] = cl - 1;",
		"    }",
		"    vi q(n), d(n);",
		"    for (int h = 1; h < n; h<<=1) {",
		"        For(i,0,n){",
		"            q[i] = p[i] - h;",
		"            if (q[i] < 0) q[i]+=n;",
		"        }",
		"        fill(f.begin(), f.begin() + cl, 0);",
		"        For(i,0,n) f[c[q[i]]]++;",
		"        partial_sum(f.begin(), f.begin() + cl, f.begin());",
		"        Fore(i,n-1,0) p[--f[c[q[i]]]] = q[i];",
		"        d[p[0]] = 0;",
		"        cl = 1;",
		"        For(i,1,n){",
		"            if (c[p[i]] != c[p[i - 1]] || c[(p[i] + h) % n] != c[(p[i - 1] + h) % n]) cl++;",
		"            d[p[i]] = cl - 1;",
		"        }",
		"        c.swap(d);",
		"    }",
		"    p.erase(p.begin());",
		"    return p;",
		"}",
		"vi lcp(const string &s, const vi &p) {",
		"    int n = sz(s);",
		"    vi r(n), l(n - 1);",
		"    For(i,0,n) r[p[i]] = i;",
		"    int k = 0;",
		"    For(i,0,n){",
		"        if (r[i] == n - 1) {k = 0; continue;}",
		"        int j = p[r[i] + 1];",
		"        while (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;",
		"        l[r[i]] = k;",
		"        if (k) k--;",
		"    }",
		"    return l;",
		"}"
	],
	"description": "suffix_array"
	},
	"lagrange": {
	"prefix": "lagrange",
	"body": [
		"const int N = 1e6 + 3;",
		"ll fact[N], invfact[N], pre[N], suf[N];",
		"ll add(ll x, ll y) {return add(x, y, mod);}",
		"ll sub(ll x, ll y) {return sub(x, y, mod);}",
		"ll mul(ll x, ll y) {return mul(x, y, mod);}",
		"void calfact() {",
		"    fact[0] = 1;",
		"    For(i,1,N) fact[i] = mul(fact[i - 1], i);",
		"    invfact[N - 1] = power(fact[N - 1], mod - 2, mod);",
		"    Fore(i,N-2,0) invfact[i] = invfact[i + 1]*(i + 1) % mod;",
		"}",
		"ll lagrange(const vll &a, ll t) {",
		"    int n = sz(a) - 1;",
		"    if (t <= n) return a[t];",
		"    pre[0] = t % mod;",
		"    FOR(i,1,n) pre[i] = mul(pre[i - 1], (t - i) % mod);",
		"    suf[n] = (t - n) % mod;",
		"    Fore(i,n-1,0) suf[i] = mul(suf[i + 1], (t - i) % mod);",
		"    ll x = 0;",
		"    FOR(i,0,n){",
		"        ll p = a[i];",
		"        if (i > 0) p = mul(p, pre[i - 1]);",
		"        if (i < n) p = mul(p, suf[i + 1]);",
		"        ll q = mul(invfact[i], invfact[n - i]);",
		"        if ((n - i) & 1) q = mod - q;",
		"        x = add(x, mul(p, q));",
		"    }",
		"    return x;",
		"}"
	],
	"description": "lagrange"
	},
	"persistent_segtree": {
	"prefix": "persistent_segtree",
	"body": [
		"template<class T>",
		"struct persistent_segtree {",
		"    struct node {",
		"        int l, r; T s;",
		"        node(int x = 0, int y = 0, T z = 0) {l = x; r = y; s = z;}",
		"    };",
		"    T neutral = 0;",
		"    vector<node> t;",
		"    int n, c, cv;",
		"    vector<int> ver;",
		"    T merge(T a, T b) {return a + b;}",
		"    void init(int N, int q) {n = N; c = cv = 0; t.resize(25*q + 4*n); ver.assign(1, 1);}",
		"    void build(const vector<T> &a, int x, int l, int r) {",
		"        c = max(c, x);",
		"        if (l == r) {",
		"            t[x].s = a[l];",
		"            return;",
		"        }",
		"        t[x].l = x << 1; t[x].r = x << 1|1;",
		"        int m = (l + r) >> 1;",
		"        build(a, x << 1, l, m); build(a, x << 1|1, m + 1, r);",
		"        t[x].s = merge(t[x << 1].s, t[x << 1|1].s);",
		"    }",
		"    int set(int i, T v, int x, int l, int r) {",
		"        c++;",
		"        if (l == r) {",
		"            t[c] = node(0, 0, v);",
		"            return c;",
		"        }",
		"        int m = (l + r) >> 1, cur = c;",
		"        if (i <= m) {",
		"            t[c].l = c + 1;",
		"            t[c].r = t[x].r;",
		"            set(i, v, t[x].l, l, m);",
		"            t[cur].s = merge(t[t[cur].l].s, t[t[cur].r].s);",
		"        } else {",
		"            t[c].l = t[x].l;",
		"            t[c].r = c + 1;",
		"            set(i, v, t[x].r, m + 1, r);",
		"            t[cur].s = merge(t[t[cur].l].s, t[t[cur].r].s);",
		"        }        ",
		"        return cur;",
		"    }",
		"    int get(int l, int r, int x, int lx, int rx) {",
		"        if (lx > r || rx < l) return neutral;",
		"        if (lx >= l && rx <= r) return t[x].s;",
		"        int m = (lx + rx) >> 1;",
		"        return merge(get(l, r, t[x].l, lx, m), get(l, r, t[x].r, m + 1, rx));",
		"    }",
		"    void build(const vector<T> &a) {build(a, 1, 1, n);}",
		"    void set(int i, T v) {",
		"        if (!c) build(vector<T>(n + 1));",
		"        cv++;",
		"        ver.push_back(set(i, v, ver[cv - 1], 1, n));",
		"    }",
		"    T get(int l, int r, int ti) {return get(l, r, ver[ti], 1, n);}",
		"};"
	],
	"description": "persistent_segtree"
	},
	"hld": {
	"prefix": "hld",
	"body": [
		"const int N = 2e5 + 3;",
		"int n, q, a[N], h[N], par[N], in[N], out[N], sz[N], nxt[N], ti = -1;",
		"vi g[N];",
		"$1 s;",
		"void dfs(int u, int p) {",
		"    sz[u] = 1;",
		"    trav(v,g[u]){",
		"        if (v != p) {",
		"            h[v] = h[u] + 1;",
		"            par[v] = u;",
		"            g[v].erase(find(all(g[v]), u));",
		"            dfs(v, u);",
		"            sz[u]+=sz[v];",
		"            if (sz[v] > sz[g[u][0]]) swap(v, g[u][0]);",
		"        }",
		"    }",
		"}",
		"void hld(int u) {",
		"    in[u] = ++ti;",
		"    trav(v,g[u]){",
		"        nxt[v] = (v == g[u][0] ? nxt[u]: v);",
		"        hld(v);",
		"    }",
		"    out[u] = ti;",
		"}",
		"int query(int u, int v) {",
		"    int x = 0;",
		"    while (nxt[u] != nxt[v]) {",
		"        if (h[nxt[u]] < h[nxt[v]]) swap(u, v);",
		"        x = max(x, s.get(in[nxt[u]], in[u]));",
		"        u = par[nxt[u]];",
		"    }",
		"    if (h[u] > h[v]) swap(u, v);",
		"    x = max(x, s.get(in[u], in[v]));",
		"    return x;",
		"}"
	],
	"description": "hld"
	},
	"dsu_rollback": {
	"prefix": "dsu_rollback",
	"body": [
		"struct dsu_rollback {",
		"    struct node {",
		"        int u, v, su, sv;",
		"        node(int u, int v, int su, int sv): u(u), v(v), su(su), sv(sv) {}",
		"    };",
		"    vector<int> p, s;",
		"    vector<node> o;",
		"    int c;",
		"    void init(int n) {",
		"        p.resize(n); iota(all(p), 0); s.assign(n, 1);",
		"        o.clear();",
		"        c = n;",
		"    }",
		"    int get(int u) {return u == p[u] ? u: get(p[u]);}",
		"    bool merge(int u, int v) {",
		"        u = get(u), v = get(v);",
		"        if (u != v) {",
		"            c--;",
		"            if (s[u] < s[v]) swap(u, v);",
		"            o.push_back(node(u, v, s[u], s[v]));",
		"            p[v] = u;",
		"            s[u]+=s[v];",
		"            return 1;",
		"        }",
		"        return 0;",
		"    }",
		"    void rollback() {",
		"        if (o.empty()) return;",
		"        auto x = o.back(); o.pop_back();",
		"        c++;",
		"        int u = x.u, v = x.v;",
		"        p[u] = u; p[v] = v;",
		"        s[u] = x.su; s[v] = x.sv;",
		"    }",
		"};"
	],
	"description": "dsu_rollback"
	},
	"query_tree": {
	"prefix": "query_tree",
	"body": [
		"struct dsu_rollback {",
		"    struct node {",
		"        int u, v, su, sv;",
		"        node(int u, int v, int su, int sv): u(u), v(v), su(su), sv(sv) {}",
		"    };",
		"    vector<int> p, s;",
		"    vector<node> o;",
		"    int c;",
		"    void init(int n) {",
		"        p.resize(n); iota(all(p), 0); s.assign(n, 1);",
		"        o.clear();",
		"        c = n;",
		"    }",
		"    int get(int u) {return u == p[u] ? u: get(p[u]);}",
		"    bool merge(int u, int v) {",
		"        u = get(u), v = get(v);",
		"        if (u != v) {",
		"            c--;",
		"            if (s[u] < s[v]) swap(u, v);",
		"            o.push_back(node(u, v, s[u], s[v]));",
		"            p[v] = u;",
		"            s[u]+=s[v];",
		"            return 1;",
		"        }",
		"        return 0;",
		"    }",
		"    void rollback() {",
		"        if (o.empty()) return;",
		"        auto x = o.back(); o.pop_back();",
		"        c++;",
		"        int u = x.u, v = x.v;",
		"        p[u] = u; p[v] = v;",
		"        s[u] = x.su; s[v] = x.sv;",
		"    }",
		"};",
		"struct query_tree {",
		"    struct query {",
		"        int u, v;",
		"        bool uni;",
		"        query(int u, int v, bool uni = 0): u(u), v(v), uni(uni) {}",
		"    };",
		"    dsu_rollback d;",
		"    vector<vector<query>> t;",
		"    vector<int> a;",
		"    int n;",
		"    void init(int T, int m) {",
		"        n = T; t.resize(4*n); a.resize(n);",
		"        d.init(m);",
		"    }",
		"    void add(int x, int lx, int rx, int l, int r, query q) {",
		"        if (lx > r || rx < l) return;",
		"        if (lx >= l && rx <= r) {",
		"            t[x].push_back(q);",
		"            return;",
		"        }",
		"        int m = (lx + rx) >> 1;",
		"        add(x << 1, lx, m, l, r, q); add(x << 1|1, m + 1, rx, l, r, q);",
		"    }",
		"    void dfs(int x, int l, int r) {",
		"        for (auto &q: t[x]) q.uni = d.merge(q.u, q.v);",
		"        if (l == r) a[l] = d.c;",
		"        else {",
		"            int m = (l + r) >> 1;",
		"            dfs(x << 1, l, m); dfs(x << 1|1, m + 1, r);",
		"        }",
		"        for (auto q: t[x]) {",
		"            if (q.uni) d.rollback();",
		"        }",
		"    }",
		"    void add(int u, int v, int l, int r) {",
		"        add(1, 0, n - 1, l, r, query(u, v));",
		"    }",
		"    vector<int> solve() {",
		"        dfs(1, 0, n - 1);",
		"        return a;",
		"    }",
		"};"
	],
	"description": "query_tree"
	},
	"twosat": {
	"prefix": "twosat",
	"body": [
		"struct twosat {",
		"    vector<vector<int>> g, G;",
		"    vector<int> ord, a;",
		"    vector<bool> c;",
		"    int n, k;",
		"    void init(int N) {",
		"        n = N; k = 0;",
		"        g.assign(n, vector<int>()); G.assign(n, vector<int>());",
		"        c.assign(n, 0); a.assign(n, 0);",
		"        ord.clear();",
		"    }",
		"    void add(int u, int v) {",
		"        g[u].push_back(v); G[v].push_back(u);",
		"    }",
		"    void dfs(int u) {",
		"        c[u] = 1;",
		"        for (int v: g[u]) {",
		"            if (!c[v]) dfs(v);",
		"        }",
		"        ord.push_back(u);",
		"    }",
		"    void kosa(int u) {",
		"        a[u] = k;",
		"        c[u] = 1;",
		"        for (int v: G[u]) {",
		"            if (!c[v]) kosa(v);",
		"        }",
		"    }",
		"    vector<int> solve() {",
		"        for (int i = 0; i < n; i++) {",
		"            if (!c[i]) dfs(i);",
		"        }",
		"        fill(all(c), 0);",
		"        for (int i = sz(ord) - 1; i >= 0; i--) {",
		"            if (!c[ord[i]]) k++, kosa(ord[i]);",
		"        }",
		"        return a;",
		"    }",
		"    bool check() {",
		"        solve();",
		"        for (int i = 0; i < n; i+=2) {",
		"            if (a[i] == a[i^1]) return 0;",
		"        }",
		"        return 1;",
		"    }",
		"};"
	],
	"description": "twosat"
	},
	"lichao_max": {
	"prefix": "lichao_max",
	"body": [
		"struct lichao_max {",
		"    static const ll inf = LLONG_MAX;",
		"    ll p, q;  ",
		"    struct line {",
		"        ll k, m;",
		"        line(ll k = 0, ll m = 0): k(k), m(m) {}",
		"        ll eval(ll x) {return k*x + m;}",
		"    };",
		"    struct node {",
		"        line a = line(0, -inf);",
		"        node *lt = nullptr, *rt = nullptr;",
		"        void add(ll l, ll r, line s) {",
		"            ll m = (l + r) >> 1;",
		"            bool L = a.eval(l) < s.eval(l), M = a.eval(m) < s.eval(m), R = a.eval(r) < s.eval(r);",
		"            if (M) swap(a, s);",
		"            if (l == r) return;",
		"            if (L != M) {",
		"                if (!lt) lt = new node;",
		"                lt->add(l, m, s);",
		"            } else if (R != M) {",
		"                if (!rt) rt = new node;",
		"                rt->add(m + 1, r, s);",
		"            }",
		"        }",
		"        ll query(ll l, ll r, ll x) {",
		"            ll m = (l + r) >> 1, v = a.eval(x);",
		"            if (x <= m && lt) v = max(v, lt->query(l, m, x));",
		"            if (x > m && rt) v = max(v, rt->query(m + 1, r, x));",
		"            return v;",
		"        }",
		"    } root;",
		"    void init(ll min_x, ll max_x) {p = min_x; q = max_x;}",
		"    void add(ll k, ll m) {root.add(p, q, line(k, m));}",
		"    ll query(ll x) {return root.query(p, q, x);}",
		"};"
	],
	"description": "lichao_max"
	},
	"lichao_min": {
	"prefix": "lichao_min",
	"body": [
		"struct lichao_min {",
		"    static const ll inf = LLONG_MAX;",
		"    ll p, q;  ",
		"    struct line {",
		"        ll k, m;",
		"        line(ll k = 0, ll m = 0): k(k), m(m) {}",
		"        ll eval(ll x) {return k*x + m;}",
		"    };",
		"    struct node {",
		"        line a = line(0, inf);",
		"        node *lt = nullptr, *rt = nullptr;",
		"        void add(ll l, ll r, line s) {",
		"            ll m = (l + r) >> 1;",
		"            bool L = a.eval(l) > s.eval(l), M = a.eval(m) > s.eval(m), R = a.eval(r) > s.eval(r);",
		"            if (M) swap(a, s);",
		"            if (l == r) return;",
		"            if (L != M) {",
		"                if (!lt) lt = new node;",
		"                lt->add(l, m, s);",
		"            } else if (R != M) {",
		"                if (!rt) rt = new node;",
		"                rt->add(m + 1, r, s);",
		"            }",
		"        }",
		"        ll query(ll l, ll r, ll x) {",
		"            ll m = (l + r) >> 1, v = a.eval(x);",
		"            if (x <= m && lt) v = min(v, lt->query(l, m, x));",
		"            if (x > m && rt) v = min(v, rt->query(m + 1, r, x));",
		"            return v;",
		"        }",
		"    } root;",
		"    void init(ll min_x, ll max_x) {p = min_x; q = max_x;}",
		"    void add(ll k, ll m) {root.add(p, q, line(k, m));}",
		"    ll query(ll x) {return root.query(p, q, x);}",
		"};"
	],
	"description": "lichao_min"
	},
	"lca_sparse": {
	"prefix": "lca_sparse",
	"body": [
		"struct lca_sparse {",
		"    int n, l, ti;",
		"    vector<vector<int>> g, s;",
		"    vector<int> e, t, d, f, in;",
		"    void init(int n) {",
		"        l = Log2(n) + 3;",
		"        g.assign(n + 1, vector<int>());",
		"        s.assign(l, vector<int>(2*n + 5));",
		"        d.assign(n + 1, 0);",
		"        in.assign(n + 1, 0);",
		"        f.assign(n + 1, 0);",
		"        t = e = vi(1);",
		"        ti = 0;",
		"    }",
		"    void add(int u, int v) {",
		"        g[u].push_back(v); g[v].push_back(u);",
		"    }",
		"    void dfs(int u, int p) {",
		"        in[u] = ++ti;",
		"        f[u] = sz(e);",
		"        e.push_back(in[u]);",
		"        t.push_back(u);",
		"        for (int v: g[u]) {",
		"            if (v != p) {",
		"                d[v] = d[u] + 1;",
		"                dfs(v, u);",
		"                e.push_back(in[u]);",
		"            }",
		"        }",
		"    }",
		"    void sparse() {",
		"        int m = sz(e);",
		"        for (int i = 1; i < m; i++) s[0][i] = e[i];",
		"        for (int i = 1; i < l; i++) {",
		"            for (int j = 1; j <= m - (1 << i); j++) s[i][j] = min(s[i - 1][j], s[i - 1][j + (1 << (i - 1))]);",
		"        }",
		"    }",
		"    int query(int l, int r) {",
		"        int i = Log2(r - l + 1);",
		"        return min(s[i][l], s[i][r - (1 << i) + 1]);",
		"    }",
		"    void build() {",
		"        dfs(1, 0);",
		"        sparse();",
		"    }",
		"    int lca(int u, int v) {",
		"        u = f[u]; v = f[v];",
		"        if (u > v) swap(u, v);",
		"        return t[query(u, v)];",
		"    }",
		"    int dis(int u, int v) {",
		"        return d[u] + d[v] - 2*d[lca(u, v)];",
		"    }",
		"};"
	],
	"description": "lca_sparse"
	},
	"xor_basis": {
	"prefix": "xor_basis",
	"body": [
		"template<class T>",
		"struct xor_basis {",
		"    int d, s;",
		"    vector<T> a;",
		"    xor_basis(int n) {",
		"        d = n;",
		"        s = 0;",
		"        a.assign(d, 0);",
		"    }",
		"    bool add(T x) {",
		"        for (int i = d - 1; i >= 0; i--) {",
		"            if ((x >> i) & 1) {",
		"                if (!a[i]) {",
		"                    a[i] = x;",
		"                    s++;",
		"                    return 1;",
		"                }",
		"                x^=a[i];",
		"            }",
		"        }",
		"        return 0;",
		"    }",
		"    bool check(T x) {",
		"        for (int i = d - 1; i >= 0; i--) {",
		"            if ((x >> i) & 1) {",
		"                if (!a[i]) return 0;",
		"                x^=a[i];",
		"            }",
		"        }",
		"        return 1;",
		"    }",
		"};"
	],
	"description": "xor_basis"
	},
	"subarray_maximum": {
	"prefix": "subarray_maximum",
	"body": [
		"const int N = 1e5 + 5;",
		"struct node {",
		"    int pf, sf, s, v;",
		"    node(int pf = 0, int sf = 0, int s = 0, int v = 0): pf(pf), sf(sf), s(s), v(v) {}",
		"} t[4*N];",
		"int a[N];",
		"node op(node x, node y) {return node(max(x.pf, x.s + y.pf), max(y.sf, y.s + x.sf), x.s + y.s, max({x.v, y.v, x.sf + y.pf}));}",
		"void build(int x, int l, int r) {",
		"    if (l == r) {",
		"        t[x] = node(a[l], a[l], a[l], a[l]);",
		"        return;",
		"    }",
		"    int m = (l + r) >> 1;",
		"    build(x << 1, l, m); build(x << 1|1, m + 1, r);",
		"    t[x] = op(t[x << 1], t[x << 1|1]);",
		"}",
		"void upd(int x, int l, int r, int i, int v) {",
		"    if (l == r) {",
		"        t[x] = node(v, v, v, v);",
		"        return;",
		"    }",
		"    int m = (l + r) >> 1;",
		"    if (i <= m) upd(x << 1, l, m, i, v);",
		"    else upd(x << 1|1, m + 1, r, i, v);",
		"    t[x] = op(t[x << 1], t[x << 1|1]);",
		"}",
		"node que(int x, int lx, int rx, int l, int r) {",
		"    if (lx >= l && rx <= r) return t[x];",
		"    int m = (lx + rx) >> 1;",
		"    if (m + 1 > r || rx < l) return que(x << 1, lx, m, l, r);",
		"    if (lx > r || m < l) return que(x << 1|1, m + 1, rx, l, r);",
		"    return op(que(x << 1, lx, m, l, r), que(x << 1|1, m + 1, rx, l, r));",
		"}"
	],
	"description": "subarray_maximum"
	},
	"pudding_monster": {
	"prefix": "pudding_monster",
	"body": [
		"const int N = 3e5 + 5;",
		"int n, t, a[N], lx[N], ln[N], rx[N], rn[N];",
		"int f[N << 1];",
		"ll x = 0;",
		"void dnc(int l, int r) {",
		"    if (l == r) return;",
		"    // cout << l + 1 << ' ' << r + 1 << ' ' << x << ' ';",
		"    int m = (l + r) >> 1;",
		"    lx[m] = ln[m] = a[m];",
		"    Fore(i,m-1,l) lx[i] = max(lx[i + 1], a[i]), ln[i] = min(ln[i + 1], a[i]);",
		"    rx[m + 1] = rn[m + 1] = a[m + 1];",
		"    FOR(i,m+2,r) rx[i] = max(rx[i - 1], a[i]), rn[i] = min(rn[i - 1], a[i]);",
		"    //mx,mn E left. j=mx-mn+i-u",
		"    FOR(i,l,m){",
		"        int mx = lx[i], mn = ln[i];",
		"        FOR(u,0,t){",
		"            int j = mx - mn + i - u;",
		"            if (j > m && j <= r && rx[j] < mx && rn[j] > mn) x++;",
		"        }",
		"    }",
		"    // cout << x << ' ';",
		"    //mx,mn E right. i=j-mx+mn+u",
		"    FOR(j,m+1,r){",
		"        int mx = rx[j], mn = rn[j];",
		"        FOR(u,0,t){",
		"            int i = j - mx + mn + u;",
		"            if (i >= l && i <= m && lx[i] < mx && ln[i] > mn) x++;",
		"        }",
		"    }",
		"    // cout << x << ' ';",
		"    //mn E left, mx E right. mx-mn=j-i+u. mx-j=mn-i+u",
		"    f[rx[r] - r + N]++;",
		"    for (int i = l, j = r, k = r; i <= m; i++) {",
		"        //ln[i]<rn[j] & lx[i]<rx[k]",
		"        //ln[i] tang  & lx[i] giam",
		"        while (j > m && ln[i] > rn[j]) f[rx[j] - j + N]--, j--;",
		"        if (j == m) break;",
		"        if (rx[k] < lx[i]) continue;",
		"        while (k > m + 1 && rx[k - 1] > lx[i]) k--, f[rx[k] - k + N]++;",
		"        //<=j,>=k",
		"        if (k <= j) {",
		"            FOR(u,0,t) x+=f[ln[i] - i + u + N];",
		"        }",
		"    }",
		"    FOR(i,m+1,r) f[rx[i] - i + N] = 0;",
		"    // memset(f, 0, sizeof(f));",
		"    // cout << x << ' ';",
		"    //mx E left, mn E right. mx-mn=j-i+u. mx+i-u=mn+j",
		"    f[rn[r] + r]++;",
		"    for (int i = l, j = r, k = r; i <= m; i++) {",
		"        //ln[i]>rn[j] & lx[i]>rx[k]",
		"        //ln[i] tang  & lx[i] giam",
		"        if (ln[i] < rn[j]) continue;",
		"        while (j > m + 1 && ln[i] > rn[j - 1]) j--, f[rn[j] + j]++;",
		"        while (k > m && lx[i] < rx[k]) f[rn[k] + k]--, k--;",
		"        if (k == m) break;",
		"        if (j <= k) {",
		"            FOR(u,0,t){",
		"                if (lx[i] + i - u >= 0) x+=f[lx[i] + i - u];",
		"            }",
		"        }",
		"    }",
		"    FOR(i,m+1,r) f[rn[i] + i] = 0;",
		"    // memset(f, 0, sizeof(f));",
		"    // cout << x << '\\n';",
		"    dnc(l, m); dnc(m + 1, r);",
		"}"
	],
	"description": "pudding_monster"
	},
	"miller_rabin": {
	"prefix": "miller_rabin",
	"body": [
		"ull modmul(ull a, ull b, ull M) {",
		"    ll ret = a * b - M * (ull)(1.L / M * a * b);",
		"    return ret + M * (ret < 0) - M * (ret >= (ll)M);",
		"}",
		"ull modpow(ull b, ull e, ull mod) {",
		"    ull ans = 1;",
		"    for (; e; b = modmul(b, b, mod), e /= 2)",
		"    if (e & 1) ans = modmul(ans, b, mod);",
		"    return ans;",
		"}",
		"bool miller_rabin(ull n) {",
		"    if (n < 2 || n % 6 % 4 != 1) return (n|1) == 3;",
		"    ull s = __builtin_ctzll(n - 1), d = n >> s;",
		"    for (ull a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {",
		"        ull p = modpow(a%n, d, n), i = s;",
		"        while (p != 1 && p != n - 1 && a % n && i--) p = modmul(p, p, n);",
		"        if (p != n - 1 && i != s) return 0;",
		"    }",
		"    return 1;",
		"}"
	],
	"description": "miller_rabin"
	},
		"factor": {
	"prefix": "factor",
	"body": [
		"ull pollard(ull n) {",
		"    ull x = 0, y = 0, t = 30, prd = 2, i = 1, q;",
		"    auto f = [&](ull x) { return modmul(x, x, n) + i; };",
		"    while (t++ % 40 || __gcd(prd, n) == 1) {",
		"        if (x == y) x = ++i, y = f(x);",
		"        if ((q = modmul(prd, max(x,y) - min(x,y), n))) prd = q;",
		"        x = f(x), y = f(f(y));",
		"    }",
		"    return __gcd(prd, n);",
		"}",
		"vector<ull> factor(ull n) {",
		"    if (n == 1) return {};",
		"    if (miller_rabin(n)) return {n};",
		"    ull x = pollard(n);",
		"    auto l = factor(x), r = factor(n / x);",
		"    l.insert(l.end(), all(r));",
		"    return l;",
		"}"
	],
	"description": "factor"
	},
	"Ckn": {
	"prefix": "Ckn",
	"body": [
		"ll inv(ll a, ll m) {",
		"    ll ax = 1, mx = 0, rx = 0, r = 0, q = 0;",
		"    while (m) {",
		"        q = a/m; r = a - q*m;",
		"        a = m; m = r;",
		"        rx = ax - q*mx;",
		"        ax = mx, mx = rx;",
		"    }",
		"    return ax;",
		"}",
		"pll fact(ll n, ll p, ll e) {",
		"    ll t = n, pw = 0, r = 1;",
		"    while (t) pw+=(t/=p);",
		"    ll m = power(p, e);",
		"    while (n) {",
		"        t = 1;",
		"        FOR(i,1,m){",
		"            if (i % p != 0) t = t*i % m;",
		"        }",
		"        r = r*power(t, n/m, m) % m;",
		"        FOR(i,1,n%m){",
		"            if (i % p != 0) r = r*i % m;",
		"        }",
		"        n/=p;",
		"    }",
		"    return {pw, r};",
		"}",
		"ll cal(ll n, ll k, ll p, ll e) {",
		"    auto [p1, r1] = fact(n, p, e);",
		"    auto [p2, r2] = fact(k, p, e);",
		"    auto [p3, r3] = fact(n - k, p, e);",
		"    ll m = power(p, e);",
		"    ll x = r1*power(p, p1 - p2 - p3) % m*inv(r2, m) % m*inv(r3, m) % m;",
		"    return (x + m) % m;",
		"}",
		"int main() {",
		"    ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);",
		"    cout << fixed << setprecision(10);",
		"    ll n, k, m; cin >> n >> k >> m;",
		"    ll M = m;",
		"    vll p, e;",
		"    for (ll i = 2; i*i <= m; i++) {",
		"        if (m % i == 0) {",
		"            p.pb(i);",
		"            e.pb(0);",
		"            while (m % i == 0) e.back()++, m/=i;",
		"        }",
		"    }",
		"    if (m > 1) p.pb(m), e.pb(1);",
		"    m = M;",
		"    ll x = 0;",
		"    For(i,0,sz(p)){",
		"        ll a = cal(n, k, p[i], e[i]), md = power(p[i], e[i]);",
		"        ll c = m/md;",
		"        x = add(x, a*c % m*inv(c, md) % m, m);",
		"    }",
		"    cout << (x + m) % m;",
		"    cerr << \"\\nProcess returned 0 (0x0)   execution time :  \" << 0.001*clock() << \" s\";",
		"    return 0;",
		"}"
	],
	"description": "Ckn"
	},
	"python_fast_input": {
	"prefix": "python_fast_input",
	"body": [
		"import sys, os",
		"from io import BytesIO, IOBase",
		"class FastIO(IOBase):",
		"    newlines = 0",
		"    def __init__(self, file):",
		"        self._fd = file.fileno()",
		"        self.buffer = BytesIO()",
		"        self.writable = \"x\" in file.mode or \"r\" not in file.mode",
		"        self.write = self.buffer.write if self.writable else None",
		"    def read(self):",
		"        while True:",
		"            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))",
		"            if not b:",
		"                break",
		"            ptr = self.buffer.tell()",
		"            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
		"        self.newlines = 0",
		"        return self.buffer.read()",
		"    def readline(self):",
		"        while self.newlines == 0:",
		"            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))",
		"            self.newlines = b.count(b\"\\n\") + (not b)",
		"            ptr = self.buffer.tell()",
		"            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
		"        self.newlines -= 1",
		"        return self.buffer.readline()",
		"    def flush(self):",
		"        if self.writable:",
		"            os.write(self._fd, self.buffer.getvalue())",
		"            self.buffer.truncate(0), self.buffer.seek(0)",
		"class IOWrapper(IOBase):",
		"    def __init__(self, file):",
		"        self.buffer = FastIO(file)",
		"        self.flush = self.buffer.flush",
		"        self.writable = self.buffer.writable",
		"        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
		"        self.read = lambda: self.buffer.read().decode(\"ascii\")",
		"        self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
		"sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)"
	],
	"description": "python_fast_input"
	},
}
